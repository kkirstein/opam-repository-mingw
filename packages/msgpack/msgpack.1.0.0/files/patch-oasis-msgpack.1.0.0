--- ./Makefile
+++ ./Makefile
@@ -1,5 +1,5 @@
 # OASIS_START
-# DO NOT EDIT (digest: bc1e05bfc8b39b664f29dae8dbd3ebbb)
+# DO NOT EDIT (digest: a3c674b4239234cbbe53afe090018954)
 
 SETUP = ocaml setup.ml
 
@@ -33,6 +33,9 @@
 setup.data:
 	$(SETUP) -configure $(CONFIGUREFLAGS)
 
+configure:
+	$(SETUP) -configure $(CONFIGUREFLAGS)
+
 .PHONY: build doc test all install uninstall reinstall clean distclean configure
 
 # OASIS_STOP
--- ./_tags
+++ ./_tags
@@ -1,8 +1,9 @@
 # OASIS_START
-# DO NOT EDIT (digest: d200d16ebb68919cc0ad3887a97a07c3)
+# DO NOT EDIT (digest: b5d0df55114dd2b00e69ad3964cb9106)
 # Ignore VCS directories, you can use the same kind of rule outside 
 # OASIS_START/STOP if you want to exclude directories that contains 
 # useless stuff for the build process
+true: annot, bin_annot
 <**/.svn>: -traverse
 <**/.svn>: not_hygienic
 ".bzr": -traverse
@@ -16,44 +17,44 @@
 # Library msgpack
 "lib/core/msgpack.cmxs": use_msgpack
 <lib/core/msgpack.{cma,cmxa}>: oasis_library_msgpack_byte
-<lib/core/*.ml{,i}>: oasis_library_msgpack_byte
+<lib/core/*.ml{,i,y}>: oasis_library_msgpack_byte
 <lib/core/msgpack.{cma,cmxa}>: oasis_library_msgpack_native
-<lib/core/*.ml{,i}>: oasis_library_msgpack_native
-<lib/core/*.ml{,i}>: pkg_extlib
-<lib/core/*.ml{,i}>: pkg_num
+<lib/core/*.ml{,i,y}>: oasis_library_msgpack_native
+<lib/core/*.ml{,i,y}>: pkg_extlib
+<lib/core/*.ml{,i,y}>: pkg_num
 # Library msgpack_conv
 "lib/conv/msgpack_conv.cmxs": use_msgpack_conv
 <lib/conv/msgpack_conv.{cma,cmxa}>: oasis_library_msgpack_conv_byte
-<lib/conv/*.ml{,i}>: oasis_library_msgpack_conv_byte
+<lib/conv/*.ml{,i,y}>: oasis_library_msgpack_conv_byte
 <lib/conv/msgpack_conv.{cma,cmxa}>: oasis_library_msgpack_conv_native
-<lib/conv/*.ml{,i}>: oasis_library_msgpack_conv_native
-<lib/conv/*.ml{,i}>: use_msgpack
-<lib/conv/*.ml{,i}>: pkg_meta_conv
-<lib/conv/*.ml{,i}>: pkg_extlib
-<lib/conv/*.ml{,i}>: pkg_num
+<lib/conv/*.ml{,i,y}>: oasis_library_msgpack_conv_native
+<lib/conv/*.ml{,i,y}>: pkg_extlib
+<lib/conv/*.ml{,i,y}>: pkg_meta_conv
+<lib/conv/*.ml{,i,y}>: pkg_num
+<lib/conv/*.ml{,i,y}>: use_msgpack
 # Executable test_core
-<test/core/main.{native,byte}>: use_msgpack
-<test/core/main.{native,byte}>: pkg_oUnit
 <test/core/main.{native,byte}>: pkg_extlib
 <test/core/main.{native,byte}>: pkg_num
-<test/core/*.ml{,i}>: use_msgpack
-<test/core/*.ml{,i}>: pkg_oUnit
-<test/core/*.ml{,i}>: pkg_extlib
-<test/core/*.ml{,i}>: pkg_num
+<test/core/main.{native,byte}>: pkg_oUnit
+<test/core/main.{native,byte}>: use_msgpack
+<test/core/*.ml{,i,y}>: pkg_extlib
+<test/core/*.ml{,i,y}>: pkg_num
+<test/core/*.ml{,i,y}>: pkg_oUnit
+<test/core/*.ml{,i,y}>: use_msgpack
 # Executable test_conv
-<test/conv/main.{native,byte}>: use_msgpack_conv
-<test/conv/main.{native,byte}>: use_msgpack
-<test/conv/main.{native,byte}>: pkg_oUnit
-<test/conv/main.{native,byte}>: pkg_meta_conv.syntax
-<test/conv/main.{native,byte}>: pkg_meta_conv
 <test/conv/main.{native,byte}>: pkg_extlib
+<test/conv/main.{native,byte}>: pkg_meta_conv
+<test/conv/main.{native,byte}>: pkg_meta_conv.syntax
 <test/conv/main.{native,byte}>: pkg_num
-<test/conv/*.ml{,i}>: use_msgpack_conv
-<test/conv/*.ml{,i}>: use_msgpack
-<test/conv/*.ml{,i}>: pkg_oUnit
-<test/conv/*.ml{,i}>: pkg_meta_conv.syntax
-<test/conv/*.ml{,i}>: pkg_meta_conv
-<test/conv/*.ml{,i}>: pkg_extlib
-<test/conv/*.ml{,i}>: pkg_num
+<test/conv/main.{native,byte}>: pkg_oUnit
+<test/conv/main.{native,byte}>: use_msgpack
+<test/conv/main.{native,byte}>: use_msgpack_conv
+<test/conv/*.ml{,i,y}>: pkg_extlib
+<test/conv/*.ml{,i,y}>: pkg_meta_conv
+<test/conv/*.ml{,i,y}>: pkg_meta_conv.syntax
+<test/conv/*.ml{,i,y}>: pkg_num
+<test/conv/*.ml{,i,y}>: pkg_oUnit
+<test/conv/*.ml{,i,y}>: use_msgpack
+<test/conv/*.ml{,i,y}>: use_msgpack_conv
 # OASIS_STOP
 <test/conv/*.ml{,i}>: syntax_camlp4o
--- ./configure
+++ ./configure
@@ -1,7 +1,7 @@
 #!/bin/sh
 
 # OASIS_START
-# DO NOT EDIT (digest: 425187ed8bfdbdd207fd76392dd243a7)
+# DO NOT EDIT (digest: dc86c2ad450f91ca10c931b6045d0499)
 set -e
 
 FST=true
--- ./myocamlbuild.ml
+++ ./myocamlbuild.ml
@@ -1,16 +1,13 @@
 (* OASIS_START *)
-(* DO NOT EDIT (digest: 38d7d926071e65ec3224081254cb7fed) *)
+(* DO NOT EDIT (digest: 6e298ae717d35f4ca78f4d7c3c20c4aa) *)
 module OASISGettext = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISGettext.ml" *)
+(* # 22 "src/oasis/OASISGettext.ml" *)
 
-  let ns_ str =
-    str
 
-  let s_ str =
-    str
+  let ns_ str = str
+  let s_ str = str
+  let f_ (str: ('a, 'b, 'c, 'd) format4) = str
 
-  let f_ (str : ('a, 'b, 'c, 'd) format4) =
-    str
 
   let fn_ fmt1 fmt2 n =
     if n = 1 then
@@ -18,22 +15,370 @@
     else
       fmt2^^""
 
-  let init =
+
+  let init = []
+end
+
+module OASISString = struct
+(* # 22 "src/oasis/OASISString.ml" *)
+
+
+  (** Various string utilities.
+
+      Mostly inspired by extlib and batteries ExtString and BatString libraries.
+
+      @author Sylvain Le Gall
+  *)
+
+
+  let nsplitf str f =
+    if str = "" then
     []
+    else
+      let buf = Buffer.create 13 in
+      let lst = ref [] in
+      let push () =
+        lst := Buffer.contents buf :: !lst;
+        Buffer.clear buf
+      in
+      let str_len = String.length str in
+      for i = 0 to str_len - 1 do
+        if f str.[i] then
+          push ()
+        else
+          Buffer.add_char buf str.[i]
+      done;
+      push ();
+      List.rev !lst
+
+
+  (** [nsplit c s] Split the string [s] at char [c]. It doesn't include the
+      separator.
+  *)
+  let nsplit str c =
+    nsplitf str ((=) c)
+
+
+  let find ~what ?(offset=0) str =
+    let what_idx = ref 0 in
+    let str_idx = ref offset in
+    while !str_idx < String.length str &&
+          !what_idx < String.length what do
+      if str.[!str_idx] = what.[!what_idx] then
+        incr what_idx
+      else
+        what_idx := 0;
+      incr str_idx
+    done;
+    if !what_idx <> String.length what then
+      raise Not_found
+    else
+      !str_idx - !what_idx
+
+
+  let sub_start str len =
+    let str_len = String.length str in
+    if len >= str_len then
+      ""
+    else
+      String.sub str len (str_len - len)
+
+
+  let sub_end ?(offset=0) str len =
+    let str_len = String.length str in
+    if len >= str_len then
+      ""
+    else
+      String.sub str 0 (str_len - len)
+
+
+  let starts_with ~what ?(offset=0) str =
+    let what_idx = ref 0 in
+    let str_idx = ref offset in
+    let ok = ref true in
+    while !ok &&
+          !str_idx < String.length str &&
+          !what_idx < String.length what do
+      if str.[!str_idx] = what.[!what_idx] then
+        incr what_idx
+      else
+        ok := false;
+      incr str_idx
+    done;
+    if !what_idx = String.length what then
+      true
+    else
+      false
+
+
+  let strip_starts_with ~what str =
+    if starts_with ~what str then
+      sub_start str (String.length what)
+    else
+      raise Not_found
+
+
+  let ends_with ~what ?(offset=0) str =
+    let what_idx = ref ((String.length what) - 1) in
+    let str_idx = ref ((String.length str) - 1) in
+    let ok = ref true in
+    while !ok &&
+          offset <= !str_idx &&
+          0 <= !what_idx do
+      if str.[!str_idx] = what.[!what_idx] then
+        decr what_idx
+      else
+        ok := false;
+      decr str_idx
+    done;
+    if !what_idx = -1 then
+      true
+    else
+      false
+
+
+  let strip_ends_with ~what str =
+    if ends_with ~what str then
+      sub_end str (String.length what)
+    else
+      raise Not_found
+
+
+  let replace_chars f s =
+    let buf = Buffer.create (String.length s) in
+    String.iter (fun c -> Buffer.add_char buf (f c)) s;
+    Buffer.contents buf
+
+  let lowercase_ascii =
+    replace_chars
+      (fun c ->
+         if (c >= 'A' && c <= 'Z') then
+           Char.chr (Char.code c + 32)
+         else
+           c)
+
+  let uncapitalize_ascii s =
+    if s <> "" then
+      (lowercase_ascii (String.sub s 0 1)) ^ (String.sub s 1 ((String.length s) - 1))
+    else
+      s
+
+  let uppercase_ascii =
+    replace_chars
+      (fun c ->
+         if (c >= 'a' && c <= 'z') then
+           Char.chr (Char.code c - 32)
+         else
+           c)
+
+  let capitalize_ascii s =
+    if s <> "" then
+      (uppercase_ascii (String.sub s 0 1)) ^ (String.sub s 1 ((String.length s) - 1))
+    else
+      s
+
+  let exists f str =
+    let rec iter i =
+      if i < 0 then
+        false
+      else if f str.[i] then
+        true
+      else
+        iter (pred i)
+    in
+      iter (String.length str - 1)
+
+  let is_digit c =
+    '0' <= c && c <= '9'
+
+  let is_alpha c =
+    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+
+  let is_whitespace =
+    function
+      | ' ' | '\r' | '\n' | '\t' -> true
+      |  _  -> false
 
 end
 
-module OASISExpr = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISExpr.ml" *)
+module OASISUtils = struct
+(* # 22 "src/oasis/OASISUtils.ml" *)
+
+
+  open OASISGettext
+
+
+  module MapExt =
+  struct
+    module type S =
+    sig
+      include Map.S
+      val add_list: 'a t -> (key * 'a) list -> 'a t
+      val of_list: (key * 'a) list -> 'a t
+      val to_list: 'a t -> (key * 'a) list
+    end
+
+    module Make (Ord: Map.OrderedType) =
+    struct
+      include Map.Make(Ord)
+
+      let rec add_list t =
+        function
+          | (k, v) :: tl -> add_list (add k v t) tl
+          | [] -> t
+
+      let of_list lst = add_list empty lst
+
+      let to_list t = fold (fun k v acc -> (k, v) :: acc) t []
+    end
+  end
+
+
+  module MapString = MapExt.Make(String)
+
+
+  module SetExt  =
+  struct
+    module type S =
+    sig
+      include Set.S
+      val add_list: t -> elt list -> t
+      val of_list: elt list -> t
+      val to_list: t -> elt list
+    end
+
+    module Make (Ord: Set.OrderedType) =
+    struct
+      include Set.Make(Ord)
+
+      let rec add_list t =
+        function
+          | e :: tl -> add_list (add e t) tl
+          | [] -> t
+
+      let of_list lst = add_list empty lst
+
+      let to_list = elements
+    end
+  end
+
+
+  module SetString = SetExt.Make(String)
+
+
+  let compare_csl s1 s2 =
+    String.compare (OASISString.lowercase_ascii s1) (OASISString.lowercase_ascii s2)
+
+
+  module HashStringCsl =
+    Hashtbl.Make
+      (struct
+         type t = string
+         let equal s1 s2 = (compare_csl s1 s2) = 0
+         let hash s = Hashtbl.hash (OASISString.lowercase_ascii s)
+       end)
+
+  module SetStringCsl =
+    SetExt.Make
+      (struct
+         type t = string
+         let compare = compare_csl
+       end)
+
+
+  let varname_of_string ?(hyphen='_') s =
+    if String.length s = 0 then
+      begin
+        invalid_arg "varname_of_string"
+      end
+    else
+      begin
+        let buf =
+          OASISString.replace_chars
+            (fun c ->
+               if ('a' <= c && c <= 'z')
+                 ||
+                  ('A' <= c && c <= 'Z')
+                 ||
+                  ('0' <= c && c <= '9') then
+                 c
+               else
+                 hyphen)
+            s;
+        in
+        let buf =
+          (* Start with a _ if digit *)
+          if '0' <= s.[0] && s.[0] <= '9' then
+            "_"^buf
+          else
+            buf
+        in
+          OASISString.lowercase_ascii buf
+      end
+
+
+  let varname_concat ?(hyphen='_') p s =
+    let what = String.make 1 hyphen in
+    let p =
+      try
+        OASISString.strip_ends_with ~what p
+      with Not_found ->
+        p
+    in
+    let s =
+      try
+        OASISString.strip_starts_with ~what s
+      with Not_found ->
+        s
+    in
+      p^what^s
+
+
+  let is_varname str =
+    str = varname_of_string str
 
 
+  let failwithf fmt = Printf.ksprintf failwith fmt
+
+
+  let rec file_location ?pos1 ?pos2 ?lexbuf () =
+      match pos1, pos2, lexbuf with
+      | Some p, None, _ | None, Some p, _ ->
+        file_location ~pos1:p ~pos2:p ?lexbuf ()
+      | Some p1, Some p2, _ ->
+        let open Lexing in
+        let fn, lineno = p1.pos_fname, p1.pos_lnum in
+        let c1 = p1.pos_cnum - p1.pos_bol in
+        let c2 = c1 + (p2.pos_cnum - p1.pos_cnum) in
+        Printf.sprintf (f_ "file %S, line %d, characters %d-%d")  fn lineno c1 c2
+      | _, _, Some lexbuf ->
+        file_location
+          ~pos1:(Lexing.lexeme_start_p lexbuf)
+          ~pos2:(Lexing.lexeme_end_p lexbuf)
+          ()
+      | None, None, None ->
+        s_ "<position undefined>"
+
+
+  let failwithpf ?pos1 ?pos2 ?lexbuf fmt =
+    let loc = file_location ?pos1 ?pos2 ?lexbuf () in
+    Printf.ksprintf (fun s -> failwith (Printf.sprintf "%s: %s" loc s)) fmt
+
+
+end
+
+module OASISExpr = struct
+(* # 22 "src/oasis/OASISExpr.ml" *)
+
 
   open OASISGettext
+  open OASISUtils
 
-  type test = string 
 
+  type test = string
   type flag = string 
 
+
   type t =
     | EBool of bool
     | ENot of t
@@ -114,9 +462,10 @@
 end
 
 
-# 117 "myocamlbuild.ml"
+# 465 "myocamlbuild.ml"
 module BaseEnvLight = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseEnvLight.ml" *)
+(* # 22 "src/base/BaseEnvLight.ml" *)
+
 
   module MapString = Map.Make(String)
 
@@ -120,25 +469,16 @@
 
   module MapString = Map.Make(String)
 
+
   type t = string MapString.t
 
-  let default_filename =
-    Filename.concat
-      (Sys.getcwd ())
-      "setup.data"
 
-  let load ?(allow_empty=false) ?(filename=default_filename) () =
-    if Sys.file_exists filename then
-      begin
-        let chn =
-          open_in_bin filename
-        in
-        let st =
-          Stream.of_channel chn
-        in
-        let line =
-          ref 1
-        in
+  let default_filename = Filename.concat (Sys.getcwd ()) "setup.data"
+
+
+  let load ?(allow_empty=false) ?(filename=default_filename) ?stream () =
+    let line = ref 1 in
+    let lexer st =
         let st_line =
           Stream.from
             (fun _ ->
@@ -148,52 +488,45 @@
                    | c -> Some c
                with Stream.Failure -> None)
         in
-        let lexer =
           Genlex.make_lexer ["="] st_line
         in
-        let rec read_file mp =
-          match Stream.npeek 3 lexer with
+    let rec read_file lxr mp =
+      match Stream.npeek 3 lxr with
             | [Genlex.Ident nm; Genlex.Kwd "="; Genlex.String value] ->
-                Stream.junk lexer;
-                Stream.junk lexer;
-                Stream.junk lexer;
-                read_file (MapString.add nm value mp)
-            | [] ->
-                mp
+        Stream.junk lxr; Stream.junk lxr; Stream.junk lxr;
+        read_file lxr (MapString.add nm value mp)
+      | [] -> mp
             | _ ->
                 failwith
-                  (Printf.sprintf
-                     "Malformed data file '%s' line %d"
-                     filename !line)
-        in
-        let mp =
-          read_file MapString.empty
+          (Printf.sprintf "Malformed data file '%s' line %d" filename !line)
         in
-          close_in chn;
-          mp
-      end
-    else if allow_empty then
-      begin
+    match stream with
+    | Some st -> read_file (lexer st) MapString.empty
+    | None ->
+      if Sys.file_exists filename then begin
+        let chn = open_in_bin filename in
+        let st = Stream.of_channel chn in
+        try
+          let mp = read_file (lexer st) MapString.empty in
+          close_in chn; mp
+        with e ->
+          close_in chn; raise e
+      end else if allow_empty then begin
         MapString.empty
-      end
-    else
-      begin
+      end else begin
         failwith
           (Printf.sprintf
              "Unable to load environment, the file '%s' doesn't exist."
              filename)
       end
 
-  let var_get name env =
-    let rec var_expand str =
-      let buff =
-        Buffer.create ((String.length str) * 2)
-      in
+  let rec var_expand str env =
+    let buff = Buffer.create ((String.length str) * 2) in
         Buffer.add_substitute
           buff
           (fun var ->
              try
-               var_expand (MapString.find var env)
+           var_expand (MapString.find var env) env
              with Not_found ->
                failwith
                  (Printf.sprintf
@@ -202,51 +535,80 @@
                     str))
           str;
         Buffer.contents buff
-    in
-      var_expand (MapString.find name env)
 
-  let var_choose lst env =
-    OASISExpr.choose
-      (fun nm -> var_get nm env)
-      lst
+
+  let var_get name env = var_expand (MapString.find name env) env
+  let var_choose lst env = OASISExpr.choose (fun nm -> var_get nm env) lst
 end
 
 
-# 215 "myocamlbuild.ml"
+# 545 "myocamlbuild.ml"
 module MyOCamlbuildFindlib = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/plugins/ocamlbuild/MyOCamlbuildFindlib.ml" *)
+(* # 22 "src/plugins/ocamlbuild/MyOCamlbuildFindlib.ml" *)
+
 
   (** OCamlbuild extension, copied from 
-    * http://brion.inria.fr/gallium/index.php/Using_ocamlfind_with_ocamlbuild
+    * https://ocaml.org/learn/tutorials/ocamlbuild/Using_ocamlfind_with_ocamlbuild.html
     * by N. Pouillard and others
     *
-    * Updated on 2009/02/28
+    * Updated on 2016-06-02
     *
     * Modified by Sylvain Le Gall 
     *)
   open Ocamlbuild_plugin
 
-  (* these functions are not really officially exported *)
-  let run_and_read = 
-    Ocamlbuild_pack.My_unix.run_and_read
 
-  let blank_sep_strings = 
-    Ocamlbuild_pack.Lexers.blank_sep_strings
+  type conf = {no_automatic_syntax: bool}
 
-  let split s ch =
-    let x = 
-      ref [] 
-    in
-    let rec go s =
-      let pos = 
-        String.index s ch 
+
+  let run_and_read = Ocamlbuild_pack.My_unix.run_and_read
+
+
+  let blank_sep_strings = Ocamlbuild_pack.Lexers.blank_sep_strings
+
+
+  let exec_from_conf exec =
+    let exec =
+      let env = BaseEnvLight.load ~allow_empty:true () in
+      try
+        BaseEnvLight.var_get exec env
+      with Not_found ->
+        Printf.eprintf "W: Cannot get variable %s\n" exec;
+        exec
       in
-        x := (String.before s pos)::!x;
-        go (String.after s (pos + 1))
+    let fix_win32 str =
+      if Sys.os_type = "Win32" then begin
+        let buff = Buffer.create (String.length str) in
+        (* Adapt for windowsi, ocamlbuild + win32 has a hard time to handle '\\'.
+        *)
+        String.iter
+          (fun c -> Buffer.add_char buff (if c = '\\' then '/' else c))
+          str;
+        Buffer.contents buff
+      end else begin
+        str
+      end
     in
-      try
-        go s
-      with Not_found -> !x
+    fix_win32 exec
+
+
+  let split s ch =
+    let buf = Buffer.create 13 in
+    let x = ref [] in
+    let flush () =
+      x := (Buffer.contents buf) :: !x;
+      Buffer.clear buf
+    in
+    String.iter
+      (fun c ->
+         if c = ch then
+           flush ()
+         else
+           Buffer.add_char buf c)
+      s;
+    flush ();
+    List.rev !x
+
 
   let split_nl s = split s '\n'
 
@@ -255,31 +618,56 @@
       String.before s (String.index s ' ')
     with Not_found -> s
 
-  (* this lists all supported packages *)
+  (* ocamlfind command *)
+  let ocamlfind x = S[Sh (
+    Ocamlbuild_pack.Shell.quote_filename_if_needed
+      (exec_from_conf "ocamlfind") ); x]
+
+  (* This lists all supported packages. *)
   let find_packages () =
-    List.map before_space (split_nl & run_and_read "ocamlfind list")
+    List.map before_space (split_nl & run_and_read (exec_from_conf "ocamlfind" ^ " list"))
+
 
-  (* this is supposed to list available syntaxes, but I don't know how to do it. *)
+  (* Mock to list available syntaxes. *)
   let find_syntaxes () = ["camlp4o"; "camlp4r"]
 
-  (* ocamlfind command *)
-  let ocamlfind x = S[A"ocamlfind"; x]
 
-  let dispatch =
+  let well_known_syntax = [
+    "camlp4.quotations.o";
+    "camlp4.quotations.r";
+    "camlp4.exceptiontracer";
+    "camlp4.extend";
+    "camlp4.foldgenerator";
+    "camlp4.listcomprehension";
+    "camlp4.locationstripper";
+    "camlp4.macro";
+    "camlp4.mapgenerator";
+    "camlp4.metagenerator";
+    "camlp4.profiler";
+    "camlp4.tracer"
+  ]
+
+
+  let dispatch conf =
     function
-      | Before_options ->
-          (* by using Before_options one let command line options have an higher priority *)
-          (* on the contrary using After_options will guarantee to have the higher priority *)
-          (* override default commands by ocamlfind ones *)
+      | After_options ->
+        (* By using Before_options one let command line options have an higher
+         * priority on the contrary using After_options will guarantee to have
+         * the higher priority override default commands by ocamlfind ones *)
           Options.ocamlc     := ocamlfind & A"ocamlc";
           Options.ocamlopt   := ocamlfind & A"ocamlopt";
           Options.ocamldep   := ocamlfind & A"ocamldep";
           Options.ocamldoc   := ocamlfind & A"ocamldoc";
-          Options.ocamlmktop := ocamlfind & A"ocamlmktop"
+        Options.ocamlmktop := ocamlfind & A"ocamlmktop";
+        Options.ocamlmklib := ocamlfind & A"ocamlmklib"
                                   
       | After_rules ->
           
-          (* When one link an OCaml library/binary/package, one should use -linkpkg *)
+        (* Avoid warnings for unused tag *)
+        flag ["tests"] N;
+
+        (* When one link an OCaml library/binary/package, one should use
+         * -linkpkg *)
           flag ["ocaml"; "link"; "program"] & A"-linkpkg";
           
           (* For each ocamlfind package one inject the -package option when
@@ -287,11 +675,31 @@
            * linking. *)
           List.iter 
             begin fun pkg ->
-              flag ["ocaml"; "compile";  "pkg_"^pkg] & S[A"-package"; A pkg];
-              flag ["ocaml"; "ocamldep"; "pkg_"^pkg] & S[A"-package"; A pkg];
-              flag ["ocaml"; "doc";      "pkg_"^pkg] & S[A"-package"; A pkg];
-              flag ["ocaml"; "link";     "pkg_"^pkg] & S[A"-package"; A pkg];
-              flag ["ocaml"; "infer_interface"; "pkg_"^pkg] & S[A"-package"; A pkg];
+            let base_args = [A"-package"; A pkg] in
+            (* TODO: consider how to really choose camlp4o or camlp4r. *)
+            let syn_args = [A"-syntax"; A "camlp4o"] in
+            let (args, pargs) =
+              (* Heuristic to identify syntax extensions: whether they end in
+                 ".syntax"; some might not.
+              *)
+              if not (conf.no_automatic_syntax) &&
+                 (Filename.check_suffix pkg "syntax" ||
+                  List.mem pkg well_known_syntax) then
+                (syn_args @ base_args, syn_args)
+              else
+                (base_args, [])
+            in
+            flag ["ocaml"; "compile";  "pkg_"^pkg] & S args;
+            flag ["ocaml"; "ocamldep"; "pkg_"^pkg] & S args;
+            flag ["ocaml"; "doc";      "pkg_"^pkg] & S args;
+            flag ["ocaml"; "link";     "pkg_"^pkg] & S base_args;
+            flag ["ocaml"; "infer_interface"; "pkg_"^pkg] & S args;
+
+            (* TODO: Check if this is allowed for OCaml < 3.12.1 *)
+            flag ["ocaml"; "compile";  "package("^pkg^")"] & S pargs;
+            flag ["ocaml"; "ocamldep"; "package("^pkg^")"] & S pargs;
+            flag ["ocaml"; "doc";      "package("^pkg^")"] & S pargs;
+            flag ["ocaml"; "infer_interface"; "package("^pkg^")"] & S pargs;
             end 
             (find_packages ());
 
@@ -301,7 +709,8 @@
           flag ["ocaml"; "compile";  "syntax_"^syntax] & S[A"-syntax"; A syntax];
           flag ["ocaml"; "ocamldep"; "syntax_"^syntax] & S[A"-syntax"; A syntax];
           flag ["ocaml"; "doc";      "syntax_"^syntax] & S[A"-syntax"; A syntax];
-          flag ["ocaml"; "infer_interface"; "syntax_"^syntax] & S[A"-syntax"; A syntax];
+          flag ["ocaml"; "infer_interface"; "syntax_"^syntax] &
+          S[A"-syntax"; A syntax];
           end (find_syntaxes ());
 
           (* The default "thread" tag is not compatible with ocamlfind.
@@ -315,7 +724,13 @@
           flag ["ocaml"; "pkg_threads"; "compile"] (S[A "-thread"]);
           flag ["ocaml"; "pkg_threads"; "doc"] (S[A "-I"; A "+threads"]);
           flag ["ocaml"; "pkg_threads"; "link"] (S[A "-thread"]);
-          flag ["ocaml"; "pkg_threads"; "infer_interface"] (S[A "-thread"])
+        flag ["ocaml"; "pkg_threads"; "infer_interface"] (S[A "-thread"]);
+        flag ["c"; "pkg_threads"; "compile"] (S[A "-thread"]);
+        flag ["ocaml"; "package(threads)"; "compile"] (S[A "-thread"]);
+        flag ["ocaml"; "package(threads)"; "doc"] (S[A "-I"; A "+threads"]);
+        flag ["ocaml"; "package(threads)"; "link"] (S[A "-thread"]);
+        flag ["ocaml"; "package(threads)"; "infer_interface"] (S[A "-thread"]);
+        flag ["c"; "package(threads)"; "compile"] (S[A "-thread"]);
 
       | _ -> 
           ()
@@ -323,7 +737,8 @@
 end
 
 module MyOCamlbuildBase = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
+(* # 22 "src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
+
 
   (** Base functions for writing myocamlbuild.ml
       @author Sylvain Le Gall
@@ -339,11 +754,10 @@
   type name = string 
   type tag = string 
 
-(* # 56 "/home/mzp/.opam/system/build/oasis.0.3.0/src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
 
   type t =
       {
-        lib_ocaml: (name * dir list) list;
+        lib_ocaml: (name * dir list * string list) list;
         lib_c:     (name * dir * file list) list; 
         flags:     (tag list * (spec OASISExpr.choices)) list;
         (* Replace the 'dir: include' from _tags by a precise interdepends in
@@ -352,9 +766,9 @@
         includes:  (dir * dir list) list; 
       } 
 
-  let env_filename =
-    Pathname.basename 
-      BaseEnvLight.default_filename
+
+(* # 110 "src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
+
 
   let dispatch_combine lst =
     fun e ->
@@ -368,13 +784,9 @@
   let nm_libstubs nm =
     nm^"_stubs"
 
+
   let dispatch t e = 
-    let env = 
-      BaseEnvLight.load 
-        ~filename:env_filename 
-        ~allow_empty:true
-        ()
-    in
+    let env = BaseEnvLight.load ~allow_empty:true () in
       match e with 
         | Before_options ->
             let no_trailing_dot s =
@@ -388,7 +800,7 @@
                    try 
                      opt := no_trailing_dot (BaseEnvLight.var_get var env)
                    with Not_found ->
-                     Printf.eprintf "W: Cannot get variable %s" var)
+                     Printf.eprintf "W: Cannot get variable %s\n" var)
                 [
                   Options.ext_obj, "ext_obj";
                   Options.ext_lib, "ext_lib";
@@ -399,9 +811,13 @@
             (* Declare OCaml libraries *)
             List.iter 
               (function
-                 | nm, [] ->
-                     ocaml_lib nm
-                 | nm, dir :: tl ->
+                 | nm, [], intf_modules ->
+                     ocaml_lib nm;
+                     let cmis =
+                       List.map (fun m -> (OASISString.uncapitalize_ascii m) ^ ".cmi")
+                                intf_modules in
+                     dep ["ocaml"; "link"; "library"; "file:"^nm^".cma"] cmis
+                 | nm, dir :: tl, intf_modules ->
                      ocaml_lib ~dir:dir (dir^"/"^nm);
                      List.iter 
                        (fun dir -> 
@@ -409,7 +825,12 @@
                             (fun str ->
                                flag ["ocaml"; "use_"^nm; str] (S[A"-I"; P dir]))
                             ["compile"; "infer_interface"; "doc"])
-                       tl)
+                       tl;
+                     let cmis =
+                       List.map (fun m -> dir^"/"^(OASISString.uncapitalize_ascii m)^".cmi")
+                                intf_modules in
+                     dep ["ocaml"; "link"; "library"; "file:"^dir^"/"^nm^".cma"]
+                         cmis)
               t.lib_ocaml;
 
             (* Declare directories dependencies, replace "include" in _tags. *)
@@ -429,16 +850,18 @@
                    flag ["link"; "library"; "ocaml"; "native"; tag_libstubs lib]
                      (S[A"-cclib"; A("-l"^(nm_libstubs lib))]);
                         
+                   if bool_of_string (BaseEnvLight.var_get "native_dynlink" env) then
                    flag ["link"; "program"; "ocaml"; "byte"; tag_libstubs lib]
                      (S[A"-dllib"; A("dll"^(nm_libstubs lib))]);
 
                    (* When ocaml link something that use the C library, then one
                       need that file to be up to date.
+                      This holds both for programs and for libraries.
                     *)
-                   dep ["link"; "ocaml"; "program"; tag_libstubs lib]
+                   dep ["link"; "ocaml"; tag_libstubs lib]
                      [dir/"lib"^(nm_libstubs lib)^"."^(!Options.ext_lib)];
 
-                   dep  ["compile"; "ocaml"; "program"; tag_libstubs lib]
+                   dep  ["compile"; "ocaml"; tag_libstubs lib]
                      [dir/"lib"^(nm_libstubs lib)^"."^(!Options.ext_lib)];
 
                    (* TODO: be more specific about what depends on headers *)
@@ -455,21 +878,27 @@
               (* Add flags *)
               List.iter
               (fun (tags, cond_specs) ->
-                 let spec = 
-                   BaseEnvLight.var_choose cond_specs env
+                 let spec = BaseEnvLight.var_choose cond_specs env in
+                 let rec eval_specs =
+                   function
+                     | S lst -> S (List.map eval_specs lst)
+                     | A str -> A (BaseEnvLight.var_expand str env)
+                     | spec -> spec
                  in
-                   flag tags & spec)
+                   flag tags & (eval_specs spec))
               t.flags
         | _ -> 
             ()
 
-  let dispatch_default t =
+
+  let dispatch_default conf t =
     dispatch_combine 
       [
         dispatch t;
-        MyOCamlbuildFindlib.dispatch;
+        MyOCamlbuildFindlib.dispatch conf;
       ]
 
+
 end
 
 
@@ -473,12 +902,12 @@
 end
 
 
-# 476 "myocamlbuild.ml"
+# 905 "myocamlbuild.ml"
 open Ocamlbuild_plugin;;
 let package_default =
   {
      MyOCamlbuildBase.lib_ocaml =
-       [("msgpack", ["lib/core"]); ("msgpack_conv", ["lib/conv"])];
+       [("msgpack", ["lib/core"], []); ("msgpack_conv", ["lib/conv"], [])];
      lib_c = [];
      flags =
        [
@@ -518,12 +947,14 @@
           ("test/core", ["lib/core"]);
           ("test/conv", ["lib/conv"; "lib/core"]);
           ("lib/conv", ["lib/core"])
-       ];
+       ]
      }
   ;;
 
-let dispatch_default = MyOCamlbuildBase.dispatch_default package_default;;
+let conf = {MyOCamlbuildFindlib.no_automatic_syntax = false}
+
+let dispatch_default = MyOCamlbuildBase.dispatch_default conf package_default;;
 
-# 528 "myocamlbuild.ml"
+# 959 "myocamlbuild.ml"
 (* OASIS_STOP *)
 Ocamlbuild_plugin.dispatch dispatch_default;;
--- ./setup.ml
+++ ./setup.ml
@@ -1,23 +1,20 @@
 (* setup.ml generated for the first time by OASIS v0.3.0 *)
 
 (* OASIS_START *)
-(* DO NOT EDIT (digest: 7f4d45fbd1e8cd184087fdde89c85063) *)
+(* DO NOT EDIT (digest: 889035fd64f164e07a76bc3a180ff093) *)
 (*
-   Regenerated by OASIS v0.3.0
+   Regenerated by OASIS v0.4.7
    Visit http://oasis.forge.ocamlcore.org for more information and
    documentation about functions used in this file.
 *)
 module OASISGettext = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISGettext.ml" *)
+(* # 22 "src/oasis/OASISGettext.ml" *)
 
-  let ns_ str =
-    str
 
-  let s_ str =
-    str
+  let ns_ str = str
+  let s_ str = str
+  let f_ (str: ('a, 'b, 'c, 'd) format4) = str
 
-  let f_ (str : ('a, 'b, 'c, 'd) format4) =
-    str
 
   let fn_ fmt1 fmt2 n =
     if n = 1 then
@@ -25,75 +22,12 @@
     else
       fmt2^^""
 
-  let init =
-    []
 
-end
-
-module OASISContext = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISContext.ml" *)
-
-  open OASISGettext
-
-  type level =
-    [ `Debug
-    | `Info
-    | `Warning
-    | `Error]
-
-  type t =
-    {
-      quiet:                 bool;
-      info:                  bool;
-      debug:                 bool;
-      ignore_plugins:        bool;
-      ignore_unknown_fields: bool;
-      printf:                level -> string -> unit;
-    }
-
-  let printf lvl str =
-    let beg =
-      match lvl with
-        | `Error -> s_ "E: "
-        | `Warning -> s_ "W: "
-        | `Info  -> s_ "I: "
-        | `Debug -> s_ "D: "
-    in
-      prerr_endline (beg^str)
-
-  let default =
-    ref
-      {
-        quiet                 = false;
-        info                  = false;
-        debug                 = false;
-        ignore_plugins        = false;
-        ignore_unknown_fields = false;
-        printf                = printf;
-      }
-
-  let quiet =
-    {!default with quiet = true}
-
-
-  let args () =
-    ["-quiet",
-     Arg.Unit (fun () -> default := {!default with quiet = true}),
-     (s_ " Run quietly");
-
-     "-info",
-     Arg.Unit (fun () -> default := {!default with info = true}),
-     (s_ " Display information message");
-
-
-     "-debug",
-     Arg.Unit (fun () -> default := {!default with debug = true}),
-     (s_ " Output debug message")]
+  let init = []
 end
 
 module OASISString = struct
-(* # 1 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISString.ml" *)
-
+(* # 22 "src/oasis/OASISString.ml" *)
 
 
   (** Various string utilities.
@@ -207,56 +150,149 @@
     else
       raise Not_found
 
+
   let replace_chars f s =
-    let buf = String.make (String.length s) 'X' in
-      for i = 0 to String.length s - 1 do
-        buf.[i] <- f s.[i]
-      done;
-      buf
+    let buf = Buffer.create (String.length s) in
+    String.iter (fun c -> Buffer.add_char buf (f c)) s;
+    Buffer.contents buf
+
+  let lowercase_ascii =
+    replace_chars
+      (fun c ->
+         if (c >= 'A' && c <= 'Z') then
+           Char.chr (Char.code c + 32)
+         else
+           c)
+
+  let uncapitalize_ascii s =
+    if s <> "" then
+      (lowercase_ascii (String.sub s 0 1)) ^ (String.sub s 1 ((String.length s) - 1))
+    else
+      s
+
+  let uppercase_ascii =
+    replace_chars
+      (fun c ->
+         if (c >= 'a' && c <= 'z') then
+           Char.chr (Char.code c - 32)
+         else
+           c)
+
+  let capitalize_ascii s =
+    if s <> "" then
+      (uppercase_ascii (String.sub s 0 1)) ^ (String.sub s 1 ((String.length s) - 1))
+    else
+      s
+
+  let exists f str =
+    let rec iter i =
+      if i < 0 then
+        false
+      else if f str.[i] then
+        true
+      else
+        iter (pred i)
+    in
+      iter (String.length str - 1)
+
+  let is_digit c =
+    '0' <= c && c <= '9'
+
+  let is_alpha c =
+    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+
+  let is_whitespace =
+    function
+      | ' ' | '\r' | '\n' | '\t' -> true
+      |  _  -> false
 
 end
 
 module OASISUtils = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISUtils.ml" *)
+(* # 22 "src/oasis/OASISUtils.ml" *)
+
 
   open OASISGettext
 
-  module MapString = Map.Make(String)
 
-  let map_string_of_assoc assoc =
-    List.fold_left
-      (fun acc (k, v) -> MapString.add k v acc)
-      MapString.empty
-      assoc
+  module MapExt =
+  struct
+    module type S =
+    sig
+      include Map.S
+      val add_list: 'a t -> (key * 'a) list -> 'a t
+      val of_list: (key * 'a) list -> 'a t
+      val to_list: 'a t -> (key * 'a) list
+    end
 
-  module SetString = Set.Make(String)
+    module Make (Ord: Map.OrderedType) =
+    struct
+      include Map.Make(Ord)
 
-  let set_string_add_list st lst =
-    List.fold_left
-      (fun acc e -> SetString.add e acc)
-      st
-      lst
+      let rec add_list t =
+        function
+          | (k, v) :: tl -> add_list (add k v t) tl
+          | [] -> t
+
+      let of_list lst = add_list empty lst
+
+      let to_list t = fold (fun k v acc -> (k, v) :: acc) t []
+    end
+  end
 
-  let set_string_of_list =
-    set_string_add_list
-      SetString.empty
+
+  module MapString = MapExt.Make(String)
+
+
+  module SetExt  =
+  struct
+    module type S =
+    sig
+      include Set.S
+      val add_list: t -> elt list -> t
+      val of_list: elt list -> t
+      val to_list: t -> elt list
+    end
+
+    module Make (Ord: Set.OrderedType) =
+    struct
+      include Set.Make(Ord)
+
+      let rec add_list t =
+        function
+          | e :: tl -> add_list (add e t) tl
+          | [] -> t
+
+      let of_list lst = add_list empty lst
+
+      let to_list = elements
+    end
+  end
+
+
+  module SetString = SetExt.Make(String)
 
 
   let compare_csl s1 s2 =
-    String.compare (String.lowercase s1) (String.lowercase s2)
+    String.compare (OASISString.lowercase_ascii s1) (OASISString.lowercase_ascii s2)
+
 
   module HashStringCsl =
     Hashtbl.Make
       (struct
          type t = string
+         let equal s1 s2 = (compare_csl s1 s2) = 0
+         let hash s = Hashtbl.hash (OASISString.lowercase_ascii s)
+       end)
 
-         let equal s1 s2 =
-             (String.lowercase s1) = (String.lowercase s2)
-
-         let hash s =
-           Hashtbl.hash (String.lowercase s)
+  module SetStringCsl =
+    SetExt.Make
+      (struct
+         type t = string
+         let compare = compare_csl
        end)
 
+
   let varname_of_string ?(hyphen='_') s =
     if String.length s = 0 then
       begin
@@ -284,9 +320,10 @@
           else
             buf
         in
-          String.lowercase buf
+          OASISString.lowercase_ascii buf
       end
 
+
   let varname_concat ?(hyphen='_') p s =
     let what = String.make 1 hyphen in
     let p =
@@ -307,12 +344,526 @@
   let is_varname str =
     str = varname_of_string str
 
+
   let failwithf fmt = Printf.ksprintf failwith fmt
 
+
+  let rec file_location ?pos1 ?pos2 ?lexbuf () =
+      match pos1, pos2, lexbuf with
+      | Some p, None, _ | None, Some p, _ ->
+        file_location ~pos1:p ~pos2:p ?lexbuf ()
+      | Some p1, Some p2, _ ->
+        let open Lexing in
+        let fn, lineno = p1.pos_fname, p1.pos_lnum in
+        let c1 = p1.pos_cnum - p1.pos_bol in
+        let c2 = c1 + (p2.pos_cnum - p1.pos_cnum) in
+        Printf.sprintf (f_ "file %S, line %d, characters %d-%d")  fn lineno c1 c2
+      | _, _, Some lexbuf ->
+        file_location
+          ~pos1:(Lexing.lexeme_start_p lexbuf)
+          ~pos2:(Lexing.lexeme_end_p lexbuf)
+          ()
+      | None, None, None ->
+        s_ "<position undefined>"
+
+
+  let failwithpf ?pos1 ?pos2 ?lexbuf fmt =
+    let loc = file_location ?pos1 ?pos2 ?lexbuf () in
+    Printf.ksprintf (fun s -> failwith (Printf.sprintf "%s: %s" loc s)) fmt
+
+
+end
+
+module OASISUnixPath = struct
+(* # 22 "src/oasis/OASISUnixPath.ml" *)
+
+
+  type unix_filename = string
+  type unix_dirname = string
+
+
+  type host_filename = string
+  type host_dirname = string
+
+
+  let current_dir_name = "."
+
+
+  let parent_dir_name = ".."
+
+
+  let is_current_dir fn =
+    fn = current_dir_name || fn = ""
+
+
+  let concat f1 f2 =
+    if is_current_dir f1 then
+      f2
+    else
+      let f1' =
+        try OASISString.strip_ends_with ~what:"/" f1 with Not_found -> f1
+      in
+      f1'^"/"^f2
+
+
+  let make =
+    function
+      | hd :: tl ->
+        List.fold_left
+          (fun f p -> concat f p)
+          hd
+          tl
+      | [] ->
+        invalid_arg "OASISUnixPath.make"
+
+
+  let dirname f =
+    try
+      String.sub f 0 (String.rindex f '/')
+    with Not_found ->
+      current_dir_name
+
+
+  let basename f =
+    try
+      let pos_start =
+        (String.rindex f '/') + 1
+      in
+      String.sub f pos_start ((String.length f) - pos_start)
+    with Not_found ->
+      f
+
+
+  let chop_extension f =
+    try
+      let last_dot =
+        String.rindex f '.'
+      in
+      let sub =
+        String.sub f 0 last_dot
+      in
+      try
+        let last_slash =
+          String.rindex f '/'
+        in
+        if last_slash < last_dot then
+          sub
+        else
+          f
+      with Not_found ->
+        sub
+
+    with Not_found ->
+      f
+
+
+  let capitalize_file f =
+    let dir = dirname f in
+    let base = basename f in
+    concat dir (OASISString.capitalize_ascii base)
+
+
+  let uncapitalize_file f =
+    let dir = dirname f in
+    let base = basename f in
+    concat dir (OASISString.uncapitalize_ascii base)
+
+
+end
+
+module OASISHostPath = struct
+(* # 22 "src/oasis/OASISHostPath.ml" *)
+
+
+  open Filename
+  open OASISGettext
+
+
+  module Unix = OASISUnixPath
+
+  let bash_cmd = ref ( fun () -> "" )
+
+  let use_bash () = ( !bash_cmd () ) <> ""
+
+
+  (* generic quote and unixquote are taken from ocaml source *)
+  let generic_quote quotequote s =
+    let l = String.length s in
+    let b = Buffer.create (l + 20) in
+      Buffer.add_char b '\'';
+      for i = 0 to l - 1 do
+        if s.[i] = '\'' then
+          Buffer.add_string b quotequote
+        else
+          Buffer.add_char b  s.[i]
+      done;
+      Buffer.add_char b '\'';
+      Buffer.contents b
+
+  let unixquote = generic_quote "'\\''"
+
+  let win = Sys.os_type = "Win32"
+
+  let quote str =
+    if win && use_bash () then
+      unixquote str
+    else
+      quote str
+
+  (* uniform_path (only called, if Sys.os_type = "Win32")
+   * - enforces uniform path seperators
+   * - strips trailing slashes (exceptions in case of C:\ and / )
+   * - removes (some) unnecessary file components like ./././
+   *)
+
+  let get_naccu accu str first pos =
+    (* I assume c//d is identic to c/d
+     * the only exception (Network devices \\xyz\asdf)
+     * is covered in uniform_path
+     *)
+    if first = pos then
+      accu
+    else
+      let nlen = pos - first in
+      let nstr = String.sub str first nlen in
+        (* test/././ is the same as test *)
+        if nlen = 1 && nstr = "." then
+          accu
+        (* a/b/../ is the same as a *)
+        else if nlen = 2 && nstr = ".." then
+          match accu with
+            | []      -> [ nstr ]
+            | ".."::_ -> nstr::accu
+            | hd::tl  -> tl
+        else
+          nstr::accu
+
+  let is_path_sep = function
+    | '\\' | '/' -> true
+    | _ -> false
+
+
+  let uniform_path path_sep = function
+    | "" -> "" (* Raise an exception? Or an possible intermediate result?
+               * Filename.basename and dirname also don't raise exceptions *)
+    | str ->
+        let rec iter accu str len first pos =
+          if pos >= len then
+            List.rev (get_naccu accu str first pos)
+          else
+            let next = succ pos in
+              match is_path_sep str.[pos] with
+                | true -> iter (get_naccu accu str first pos) str len next next
+                | false -> iter accu str len first next
+        in
+          let is_unix_root = is_path_sep str.[0] in
+          let len = String.length str in
+          let next_sep = len > 1 && is_path_sep str.[1] in
+          let is_network_root = is_unix_root && next_sep in
+          let is_currel = str.[0] = '.' && ( next_sep || len = 1 ) in
+          let l = iter [] str len 0 0 in
+          (* Trailing slashes are normally stripped.
+           * This is not possible in case of root folders
+           * Sys.file_exists "C:" is false, Sys.file_exists "C:\\" true
+           *)
+          let l_min =
+            match l with
+              | [] -> [ "" ]
+              | _ -> l
+          in
+          let l =
+            if is_network_root then
+              ""::""::l_min
+            else if is_unix_root then
+              ""::l_min
+            else if is_currel then
+              "."::l
+            else
+              match l with
+                | s :: [] ->
+                    (* root folders like C:\ *)
+                    if String.length s = 2 && s.[1] = ':' &&
+                      len > 2 && is_path_sep str.[2]
+                    then
+                      s :: [ "" ]
+                    else
+                      l
+                | _ -> l
+          in
+            String.concat path_sep l
+
+
+
+  let make =
+    function
+      | [] ->
+        invalid_arg "OASISHostPath.make"
+      | hd :: tl ->
+        List.fold_left Filename.concat hd tl
+
+
+  let of_unix ufn =
+    match Sys.os_type with
+    | "Unix" | "Cygwin" -> ufn
+    | "Win32" ->
+      let path_sep =
+        if use_bash () then
+          "/"
+              else
+          "\\"
+      in
+      uniform_path path_sep ufn
+    | os_type ->
+      OASISUtils.failwithf
+        (f_ "Don't know the path format of os_type %S when translating unix \
+             filename. %S")
+        os_type ufn
+
+  (* see findlib's src/findlib/frontend.ml for details *)
+  let ocamlfind_unquote dir =
+    match Sys.os_type with
+    | "Cygwin"
+    | "Win32" ->
+      let len = String.length dir in
+      if len < 3 || dir.[0] <> '"' || dir.[len - 1] <> '"' ||
+         String.contains dir ' ' = false then
+        dir
+      else
+        String.sub dir 1 (len - 2)
+    | _ -> dir
+
+end
+
+module OASISFileSystem = struct
+(* # 22 "src/oasis/OASISFileSystem.ml" *)
+
+  (** File System functions
+
+      @author Sylvain Le Gall
+  *)
+
+  type 'a filename = string
+
+  class type closer =
+    object
+      method close: unit
+    end
+
+  class type reader =
+    object
+      inherit closer
+      method input: Buffer.t -> int -> unit
+    end
+
+  class type writer =
+    object
+      inherit closer
+      method output: Buffer.t -> unit
+    end
+
+  class type ['a] fs =
+    object
+      method string_of_filename: 'a filename -> string
+      method open_out: ?mode:(open_flag list) -> ?perm:int -> 'a filename -> writer
+      method open_in: ?mode:(open_flag list) -> ?perm:int -> 'a filename -> reader
+      method file_exists: 'a filename -> bool
+      method remove: 'a filename -> unit
+    end
+
+
+  module Mode =
+  struct
+    let default_in = [Open_rdonly]
+    let default_out = [Open_wronly; Open_creat; Open_trunc]
+
+    let text_in = Open_text :: default_in
+    let text_out = Open_text :: default_out
+
+    let binary_in = Open_binary :: default_in
+    let binary_out = Open_binary :: default_out
+  end
+
+  let std_length = 4096 (* Standard buffer/read length. *)
+  let binary_out = Mode.binary_out
+  let binary_in = Mode.binary_in
+
+  let of_unix_filename ufn = (ufn: 'a filename)
+  let to_unix_filename fn = (fn: string)
+
+
+  let defer_close o f =
+    try
+      let r = f o in o#close; r
+    with e ->
+      o#close; raise e
+
+
+  let stream_of_reader rdr =
+    let buf = Buffer.create std_length in
+    let pos = ref 0 in
+    let eof = ref false in
+    let rec next idx =
+      let bpos = idx - !pos in
+      if !eof then begin
+        None
+      end else if bpos < Buffer.length buf then begin
+        Some (Buffer.nth buf bpos)
+      end else begin
+        pos := !pos + Buffer.length buf;
+        Buffer.clear buf;
+        begin
+          try
+            rdr#input buf std_length;
+          with End_of_file ->
+            if Buffer.length buf = 0 then
+              eof := true
+        end;
+        next idx
+      end
+    in
+    Stream.from next
+
+
+  let read_all buf rdr =
+    try
+      while true do
+        rdr#input buf std_length
+      done
+    with End_of_file ->
+      ()
+
+  class ['a] host_fs rootdir : ['a] fs =
+    object (self)
+      method private host_filename fn = Filename.concat rootdir fn
+      method string_of_filename = self#host_filename
+
+      method open_out ?(mode=Mode.text_out)  ?(perm=0o666) fn =
+        let chn = open_out_gen mode perm (self#host_filename fn) in
+        object
+          method close = close_out chn
+          method output buf = Buffer.output_buffer chn buf
+        end
+
+      method open_in ?(mode=Mode.text_in) ?(perm=0o666) fn =
+        (* TODO: use Buffer.add_channel when minimal version of OCaml will
+         * be >= 4.03.0 (previous version was discarding last chars).
+         *)
+        let chn = open_in_gen mode perm (self#host_filename fn) in
+        let strm = Stream.of_channel chn in
+        object
+          method close = close_in chn
+          method input buf len =
+            let read = ref 0 in
+            try
+              for _i = 0 to len do
+                Buffer.add_char buf (Stream.next strm);
+                incr read
+              done
+            with Stream.Failure ->
+              if !read = 0 then
+                raise End_of_file
+        end
+
+      method file_exists fn = Sys.file_exists (self#host_filename fn)
+      method remove fn = Sys.remove (self#host_filename fn)
+    end
+
+end
+
+module OASISContext = struct
+(* # 22 "src/oasis/OASISContext.ml" *)
+
+
+  open OASISGettext
+
+
+  type level =
+    [ `Debug
+    | `Info
+    | `Warning
+    | `Error]
+
+
+  type source
+  type source_filename = source OASISFileSystem.filename
+
+
+  let in_srcdir ufn = OASISFileSystem.of_unix_filename ufn
+
+
+  type t =
+    {
+      (* TODO: replace this by a proplist. *)
+      quiet:                 bool;
+      info:                  bool;
+      debug:                 bool;
+      ignore_plugins:        bool;
+      ignore_unknown_fields: bool;
+      printf:                level -> string -> unit;
+      srcfs:                 source OASISFileSystem.fs;
+    }
+
+
+  let printf lvl str =
+    let beg =
+      match lvl with
+        | `Error -> s_ "E: "
+        | `Warning -> s_ "W: "
+        | `Info  -> s_ "I: "
+        | `Debug -> s_ "D: "
+    in
+    prerr_endline (beg^str)
+
+
+  let default =
+    ref
+      {
+        quiet                 = false;
+        info                  = false;
+        debug                 = false;
+        ignore_plugins        = false;
+        ignore_unknown_fields = false;
+        printf                = printf;
+        srcfs                 = new OASISFileSystem.host_fs(Sys.getcwd ());
+      }
+
+
+  let quiet =
+    {!default with quiet = true}
+
+
+  let fspecs () =
+    (* TODO: don't act on default. *)
+    let ignore_plugins = ref false in
+    ["-quiet",
+     Arg.Unit (fun () -> default := {!default with quiet = true}),
+     s_ " Run quietly";
+
+     "-info",
+     Arg.Unit (fun () -> default := {!default with info = true}),
+     s_ " Display information message";
+
+
+     "-debug",
+     Arg.Unit (fun () -> default := {!default with debug = true}),
+     s_ " Output debug message";
+
+     "-ignore-plugins",
+     Arg.Set ignore_plugins,
+     s_ " Ignore plugin's field.";
+
+     "-C",
+     Arg.String
+       (fun str ->
+          Sys.chdir str;
+          default := {!default with srcfs = new OASISFileSystem.host_fs str}),
+     s_ "dir Change directory before running (affects setup.{data,log})."],
+    fun () -> {!default with ignore_plugins = !ignore_plugins}
 end
 
 module PropList = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/PropList.ml" *)
+(* # 22 "src/oasis/PropList.ml" *)
+
 
   open OASISGettext
 
@@ -336,7 +890,8 @@
                (Printf.sprintf (f_ "No default printer for value %s") nm)
          | Unknown_field (nm, schm) ->
              Some 
-               (Printf.sprintf (f_ "Field %s is not defined in schema %s") nm schm)
+            (Printf.sprintf
+               (f_ "Field %s is not defined in schema %s") nm schm)
          | _ ->
              None)
 
@@ -352,12 +907,13 @@
     let clear t =
       Hashtbl.clear t
 
-(* # 71 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/PropList.ml" *)
+
+(* # 77 "src/oasis/PropList.ml" *)
   end
 
+
   module Schema =
   struct
-
     type ('ctxt, 'extra) value =
         {
           get:   Data.t -> string;
@@ -381,7 +937,7 @@
         order     = Queue.create ();
         name_norm =
           (if case_insensitive then
-             String.lowercase
+             OASISString.lowercase_ascii
            else
              fun s -> s);
       }
@@ -593,7 +1147,7 @@
 end
 
 module OASISMessage = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISMessage.ml" *)
+(* # 22 "src/oasis/OASISMessage.ml" *)
 
 
   open OASISGettext
@@ -632,13 +1191,11 @@
 end
 
 module OASISVersion = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISVersion.ml" *)
-
-  open OASISGettext
+(* # 22 "src/oasis/OASISVersion.ml" *)
 
 
+  open OASISGettext
 
-  type s = string
 
   type t = string 
 
@@ -653,16 +1211,10 @@
     
 
   (* Range of allowed characters *)
-  let is_digit c =
-    '0' <= c && c <= '9'
+  let is_digit = OASISString.is_digit
+  let is_alpha = OASISString.is_alpha
+  let is_special = function | '.' | '+' | '-' | '~' -> true | _ -> false
 
-  let is_alpha c =
-    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
-
-  let is_special =
-    function
-      | '.' | '+' | '-' | '~' -> true
-      | _ -> false
 
   let rec version_compare v1 v2 =
     if v1 <> "" || v2 <> "" then
@@ -739,8 +1291,7 @@
             | n ->
                 n
       end
-    else
-      begin
+    else begin
         0
       end
 
@@ -805,13 +1361,12 @@
         | VAnd (c1, c2) ->
             (varname_of_comparator c1)^"_and_"^(varname_of_comparator c2)
 
-  let version_0_3_or_after t =
-    comparator_apply t (VGreaterEqual (string_of_version "0.3"))
 
 end
 
 module OASISLicense = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISLicense.ml" *)
+(* # 22 "src/oasis/OASISLicense.ml" *)
+
 
   (** License for _oasis fields
       @author Sylvain Le Gall
@@ -851,16 +1405,17 @@
 end
 
 module OASISExpr = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISExpr.ml" *)
-
+(* # 22 "src/oasis/OASISExpr.ml" *)
 
 
   open OASISGettext
+  open OASISUtils
 
-  type test = string 
 
+  type test = string
   type flag = string 
 
+
   type t =
     | EBool of bool
     | ENot of t
@@ -938,21 +1495,163 @@
     in
       choose_aux (List.rev lst)
 
+
 end
 
-module OASISTypes = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISTypes.ml" *)
+module OASISText = struct
+(* # 22 "src/oasis/OASISText.ml" *)
+
+  type elt =
+    | Para of string
+    | Verbatim of string
+    | BlankLine
+
+  type t = elt list
+
+end
+
+module OASISSourcePatterns = struct
+(* # 22 "src/oasis/OASISSourcePatterns.ml" *)
+
+  open OASISUtils
+  open OASISGettext
+
+  module Templater =
+  struct
+    (* TODO: use this module in BaseEnv.var_expand and BaseFileAB, at least. *)
+    type t =
+      {
+        atoms: atom list;
+        origin: string
+      }
+    and atom =
+      | Text of string
+      | Expr of expr
+    and expr =
+      | Ident of string
+      | String of string
+      | Call of string * expr
+
+
+    type env =
+      {
+        variables: string MapString.t;
+        functions: (string -> string) MapString.t;
+      }
+
+
+    let eval env t =
+      let rec eval_expr env =
+        function
+        | String str -> str
+        | Ident nm ->
+          begin
+            try
+              MapString.find nm env.variables
+            with Not_found ->
+              (* TODO: add error location within the string. *)
+              failwithf
+                (f_ "Unable to find variable %S in source pattern %S")
+                nm t.origin
+          end
+
+        | Call (fn, expr) ->
+          begin
+            try
+              (MapString.find fn env.functions) (eval_expr env expr)
+            with Not_found ->
+              (* TODO: add error location within the string. *)
+              failwithf
+                (f_ "Unable to find function %S in source pattern %S")
+                fn t.origin
+          end
+      in
+      String.concat ""
+        (List.map
+           (function
+             | Text str -> str
+             | Expr expr -> eval_expr env expr)
+           t.atoms)
+
+
+    let parse env s =
+      let lxr = Genlex.make_lexer [] in
+      let parse_expr s =
+        let st = lxr (Stream.of_string s) in
+        match Stream.npeek 3 st with
+        | [Genlex.Ident fn; Genlex.Ident nm] -> Call(fn, Ident nm)
+        | [Genlex.Ident fn; Genlex.String str] -> Call(fn, String str)
+        | [Genlex.String str] -> String str
+        | [Genlex.Ident nm] -> Ident nm
+        (* TODO: add error location within the string. *)
+        | _ -> failwithf (f_ "Unable to parse expression %S") s
+      in
+      let parse s =
+        let lst_exprs = ref [] in
+        let ss =
+          let buff = Buffer.create (String.length s) in
+          Buffer.add_substitute
+            buff
+            (fun s -> lst_exprs := (parse_expr s) :: !lst_exprs; "\000")
+            s;
+          Buffer.contents buff
+        in
+        let rec join =
+          function
+          | hd1 :: tl1, hd2 :: tl2 -> Text hd1 :: Expr hd2 :: join (tl1, tl2)
+          | [], tl -> List.map (fun e -> Expr e) tl
+          | tl, [] -> List.map (fun e -> Text e) tl
+        in
+        join (OASISString.nsplit ss '\000', List.rev (!lst_exprs))
+      in
+      let t = {atoms = parse s; origin = s} in
+      (* We rely on a simple evaluation for checking variables/functions.
+         It works because there is no if/loop statement.
+      *)
+      let _s : string = eval env t in
+      t
+
+(* # 144 "src/oasis/OASISSourcePatterns.ml" *)
+  end
+
+
+  type t = Templater.t
+
+
+  let env ~modul () =
+    {
+      Templater.
+      variables = MapString.of_list ["module", modul];
+      functions = MapString.of_list
+          [
+            "capitalize_file", OASISUnixPath.capitalize_file;
+            "uncapitalize_file", OASISUnixPath.uncapitalize_file;
+          ];
+    }
+
+  let all_possible_files lst ~path ~modul =
+    let eval = Templater.eval (env ~modul ()) in
+    List.fold_left
+      (fun acc pat -> OASISUnixPath.concat path (eval pat) :: acc)
+      [] lst
+
+
+  let to_string t = t.Templater.origin
 
 
+end
+
+module OASISTypes = struct
+(* # 22 "src/oasis/OASISTypes.ml" *)
 
 
   type name          = string 
   type package_name  = string 
   type url           = string 
   type unix_dirname  = string 
-  type unix_filename = string 
-  type host_dirname  = string 
-  type host_filename = string 
+  type unix_filename = string (* TODO: replace everywhere. *)
+  type host_dirname  = string (* TODO: replace everywhere. *)
+  type host_filename = string (* TODO: replace everywhere. *)
   type prog          = string 
   type arg           = string 
   type args          = string list 
@@ -1012,13 +1714,15 @@
        | `Other of string
       ]
 
+
   type 'a plugin = 'a * name * OASISVersion.t option 
 
+
   type all_plugin = plugin_kind plugin
 
+
   type plugin_data = (all_plugin * plugin_data_purpose * (unit -> unit)) list
 
-(* # 102 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISTypes.ml" *)
 
   type 'a conditional = 'a OASISExpr.choices 
 
@@ -1045,8 +1750,11 @@
         bs_compiled_object: compiled_object;
         bs_build_depends:   dependency list;
         bs_build_tools:     tool list;
+      bs_interface_patterns:      OASISSourcePatterns.t list;
+      bs_implementation_patterns: OASISSourcePatterns.t list;
         bs_c_sources:       unix_filename list;
         bs_data_files:      (unix_filename * unix_filename option) list;
+      bs_findlib_extra_files:     unix_filename list;
         bs_ccopt:           args conditional;
         bs_cclib:           args conditional;
         bs_dlllib:          args conditional;
@@ -1063,9 +1771,19 @@
         lib_internal_modules:   string list;
         lib_findlib_parent:     findlib_name option;
         lib_findlib_name:       findlib_name option;
+      lib_findlib_directory:  unix_dirname option;
         lib_findlib_containers: findlib_name list;
       } 
 
+
+  type object_ =
+    {
+      obj_modules:            string list;
+      obj_findlib_fullname:   findlib_name list option;
+      obj_findlib_directory:  unix_dirname option;
+    }
+
+
   type executable =
       {
         exec_custom:          bool;
@@ -1099,12 +1820,13 @@
         test_tools:              tool list;
       } 
 
+
   type doc_format =
-    | HTML of unix_filename
+    | HTML of unix_filename (* TODO: source filename. *)
     | DocText
     | PDF
     | PostScript
-    | Info of unix_filename
+    | Info of unix_filename (* TODO: source filename. *)
     | DVI
     | OtherDoc
     
@@ -1115,11 +1837,12 @@
         doc_custom:      custom;
         doc_build:       bool conditional;
         doc_install:     bool conditional;
-        doc_install_dir: unix_filename;
+      doc_install_dir: unix_filename; (* TODO: dest filename ?. *)
         doc_title:       string;
         doc_authors:     string list;
         doc_abstract:    string option;
         doc_format:      doc_format;
+      (* TODO: src filename. *)
         doc_data_files:  (unix_filename * unix_filename option) list;
         doc_build_tools: tool list;
       } 
@@ -1124,8 +1847,10 @@
         doc_build_tools: tool list;
       } 
 
+
   type section =
     | Library    of common_section * build_section * library
+    | Object     of common_section * build_section * object_
     | Executable of common_section * build_section * executable
     | Flag       of common_section * flag
     | SrcRepo    of common_section * source_repository
@@ -1134,23 +1859,28 @@
     
 
   type section_kind =
-      [ `Library | `Executable | `Flag | `SrcRepo | `Test | `Doc ]
+    [ `Library | `Object | `Executable | `Flag | `SrcRepo | `Test | `Doc ]
+
 
   type package = 
       {
         oasis_version:    OASISVersion.t;
         ocaml_version:    OASISVersion.comparator option;
         findlib_version:  OASISVersion.comparator option;
+      alpha_features:         string list;
+      beta_features:          string list;
         name:             package_name;
         version:          OASISVersion.t;
         license:          OASISLicense.t;
-        license_file:     unix_filename option;
+      license_file:           unix_filename option; (* TODO: source filename. *)
         copyrights:       string list;
         maintainers:      string list;
         authors:          string list;
         homepage:         url option;
+      bugreports:             url option;
         synopsis:         string;
-        description:      string option;
+      description:            OASISText.t option;
+      tags:                   string list;
         categories:       url list;
 
         conf_type:        [`Configure] plugin;
@@ -1166,9 +1896,10 @@
         clean_custom:     custom;
         distclean_custom: custom;
 
-        files_ab:         unix_filename list;
+      files_ab:               unix_filename list; (* TODO: source filename. *)
         sections:         section list;
         plugins:          [`Extra] plugin list;
+      disable_oasis_section:  unix_filename list; (* TODO: source filename. *)
         schema_data:      PropList.Data.t;
         plugin_data:      plugin_data;
       } 
@@ -1173,127 +1904,394 @@
         plugin_data:      plugin_data;
       } 
 
+
 end
 
-module OASISUnixPath = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISUnixPath.ml" *)
+module OASISFeatures = struct
+(* # 22 "src/oasis/OASISFeatures.ml" *)
 
-  type unix_filename = string
-  type unix_dirname = string
+  open OASISTypes
+  open OASISUtils
+  open OASISGettext
+  open OASISVersion
 
-  type host_filename = string
-  type host_dirname = string
+  module MapPlugin =
+    Map.Make
+      (struct
+        type t = plugin_kind * name
+        let compare = Pervasives.compare
+      end)
 
-  let current_dir_name = "."
+  module Data =
+  struct
+    type t =
+      {
+        oasis_version: OASISVersion.t;
+        plugin_versions: OASISVersion.t option MapPlugin.t;
+        alpha_features: string list;
+        beta_features: string list;
+      }
 
-  let parent_dir_name = ".."
+    let create oasis_version alpha_features beta_features =
+      {
+        oasis_version = oasis_version;
+        plugin_versions = MapPlugin.empty;
+        alpha_features = alpha_features;
+        beta_features = beta_features
+      }
 
-  let is_current_dir fn =
-    fn = current_dir_name || fn = ""
+    let of_package pkg =
+      create
+        pkg.OASISTypes.oasis_version
+        pkg.OASISTypes.alpha_features
+        pkg.OASISTypes.beta_features
+
+    let add_plugin (plugin_kind, plugin_name, plugin_version) t =
+      {t with
+         plugin_versions = MapPlugin.add
+             (plugin_kind, plugin_name)
+             plugin_version
+             t.plugin_versions}
 
-  let concat f1 f2 =
-    if is_current_dir f1 then
-      f2
+    let plugin_version plugin_kind plugin_name t =
+      MapPlugin.find (plugin_kind, plugin_name) t.plugin_versions
+
+    let to_string t =
+      Printf.sprintf
+        "oasis_version: %s; alpha_features: %s; beta_features: %s; \
+         plugins_version: %s"
+        (OASISVersion.string_of_version (t:t).oasis_version)
+        (String.concat ", " t.alpha_features)
+        (String.concat ", " t.beta_features)
+        (String.concat ", "
+           (MapPlugin.fold
+              (fun (_, plg) ver_opt acc ->
+                 (plg^
+                    (match ver_opt with
+                      | Some v ->
+                        " "^(OASISVersion.string_of_version v)
+                      | None -> ""))
+                 :: acc)
+              t.plugin_versions []))
+  end
+
+  type origin =
+    | Field of string * string
+    | Section of string
+    | NoOrigin
+
+  type stage = Alpha | Beta
+
+
+  let string_of_stage =
+    function
+    | Alpha -> "alpha"
+    | Beta -> "beta"
+
+
+  let field_of_stage =
+    function
+    | Alpha -> "AlphaFeatures"
+    | Beta -> "BetaFeatures"
+
+  type publication = InDev of stage | SinceVersion of OASISVersion.t
+
+  type t =
+    {
+      name: string;
+      plugin: all_plugin option;
+      publication: publication;
+      description: unit -> string;
+    }
+
+  (* TODO: mutex protect this. *)
+  let all_features = Hashtbl.create 13
+
+
+  let since_version ver_str = SinceVersion (version_of_string ver_str)
+  let alpha = InDev Alpha
+  let beta = InDev Beta
+
+
+  let to_string t =
+    Printf.sprintf
+      "feature: %s; plugin: %s; publication: %s"
+      (t:t).name
+      (match t.plugin with
+       | None -> "<none>"
+       | Some (_, nm, _) -> nm)
+      (match t.publication with
+       | InDev stage -> string_of_stage stage
+       | SinceVersion ver -> ">= "^(OASISVersion.string_of_version ver))
+
+  let data_check t data origin =
+    let no_message = "no message" in
+
+    let check_feature features stage =
+      let has_feature = List.mem (t:t).name features in
+      if not has_feature then
+        match (origin:origin) with
+        | Field (fld, where) ->
+          Some
+            (Printf.sprintf
+               (f_ "Field %s in %s is only available when feature %s \
+                    is in field %s.")
+               fld where t.name (field_of_stage stage))
+        | Section sct ->
+          Some
+            (Printf.sprintf
+               (f_ "Section %s is only available when features %s \
+                    is in field %s.")
+               sct t.name (field_of_stage stage))
+        | NoOrigin ->
+          Some no_message
     else
-      let f1' =
-        try OASISString.strip_ends_with ~what:"/" f1 with Not_found -> f1
+        None
       in
-        f1'^"/"^f2
 
-  let make =
-    function
-      | hd :: tl ->
-          List.fold_left
-            (fun f p -> concat f p)
-            hd
-            tl
-      | [] ->
-          invalid_arg "OASISUnixPath.make"
+    let version_is_good ~min_version version fmt =
+      let version_is_good =
+        OASISVersion.comparator_apply
+          version (OASISVersion.VGreaterEqual min_version)
+      in
+      Printf.ksprintf
+        (fun str -> if version_is_good then None else Some str)
+        fmt
+    in
 
-  let dirname f =
+    match origin, t.plugin, t.publication with
+    | _, _, InDev Alpha -> check_feature data.Data.alpha_features Alpha
+    | _, _, InDev Beta -> check_feature data.Data.beta_features Beta
+    | Field(fld, where), None, SinceVersion min_version ->
+      version_is_good ~min_version data.Data.oasis_version
+        (f_ "Field %s in %s is only valid since OASIS v%s, update \
+             OASISFormat field from '%s' to '%s' after checking \
+             OASIS changelog.")
+        fld where (string_of_version min_version)
+        (string_of_version data.Data.oasis_version)
+        (string_of_version min_version)
+
+    | Field(fld, where), Some(plugin_knd, plugin_name, _),
+      SinceVersion min_version ->
+      begin
     try
-      String.sub f 0 (String.rindex f '/')
+          let plugin_version_current =
+            try
+              match Data.plugin_version plugin_knd plugin_name data with
+              | Some ver -> ver
+              | None ->
+                failwithf
+                  (f_ "Field %s in %s is only valid for the OASIS \
+                       plugin %s since v%s, but no plugin version is \
+                       defined in the _oasis file, change '%s' to \
+                       '%s (%s)' in your _oasis file.")
+                  fld where plugin_name (string_of_version min_version)
+                  plugin_name
+                  plugin_name (string_of_version min_version)
     with Not_found ->
-      current_dir_name
+              failwithf
+                (f_ "Field %s in %s is only valid when the OASIS plugin %s \
+                     is defined.")
+                fld where plugin_name
+          in
+          version_is_good ~min_version plugin_version_current
+            (f_ "Field %s in %s is only valid for the OASIS plugin %s \
+                 since v%s, update your plugin from '%s (%s)' to \
+                 '%s (%s)' after checking the plugin's changelog.")
+            fld where plugin_name (string_of_version min_version)
+            plugin_name (string_of_version plugin_version_current)
+            plugin_name (string_of_version min_version)
+        with Failure msg ->
+          Some msg
+      end
+
+    | Section sct, None, SinceVersion min_version ->
+      version_is_good ~min_version data.Data.oasis_version
+        (f_ "Section %s is only valid for since OASIS v%s, update \
+             OASISFormat field from '%s' to '%s' after checking OASIS \
+             changelog.")
+        sct (string_of_version min_version)
+        (string_of_version data.Data.oasis_version)
+        (string_of_version min_version)
 
-  let basename f =
+    | Section sct, Some(plugin_knd, plugin_name, _),
+      SinceVersion min_version ->
+      begin
     try
-      let pos_start =
-        (String.rindex f '/') + 1
+          let plugin_version_current =
+            try
+              match Data.plugin_version plugin_knd plugin_name data with
+              | Some ver -> ver
+              | None ->
+                failwithf
+                  (f_ "Section %s is only valid for the OASIS \
+                       plugin %s since v%s, but no plugin version is \
+                       defined in the _oasis file, change '%s' to \
+                       '%s (%s)' in your _oasis file.")
+                  sct plugin_name (string_of_version min_version)
+                  plugin_name
+                  plugin_name (string_of_version min_version)
+            with Not_found ->
+              failwithf
+                (f_ "Section %s is only valid when the OASIS plugin %s \
+                     is defined.")
+                sct plugin_name
+          in
+          version_is_good ~min_version plugin_version_current
+            (f_ "Section %s is only valid for the OASIS plugin %s \
+                 since v%s, update your plugin from '%s (%s)' to \
+                 '%s (%s)' after checking the plugin's changelog.")
+            sct plugin_name (string_of_version min_version)
+            plugin_name (string_of_version plugin_version_current)
+            plugin_name (string_of_version min_version)
+        with Failure msg ->
+          Some msg
+      end
+
+    | NoOrigin, None, SinceVersion min_version ->
+      version_is_good ~min_version data.Data.oasis_version "%s" no_message
+
+    | NoOrigin, Some(plugin_knd, plugin_name, _), SinceVersion min_version ->
+      begin
+        try
+          let plugin_version_current =
+            match Data.plugin_version plugin_knd plugin_name data with
+            | Some ver -> ver
+            | None -> raise Not_found
       in
-        String.sub f pos_start ((String.length f) - pos_start)
+          version_is_good ~min_version plugin_version_current
+            "%s" no_message
     with Not_found ->
-      f
+          Some no_message
+      end
 
-  let chop_extension f =
-    try
-      let last_dot =
-        String.rindex f '.'
+
+  let data_assert t data origin =
+    match data_check t data origin with
+    | None -> ()
+    | Some str -> failwith str
+
+
+  let data_test t data =
+    match data_check t data NoOrigin with
+    | None -> true
+    | Some _ -> false
+
+
+  let package_test t pkg =
+    data_test t (Data.of_package pkg)
+
+
+  let create ?plugin name publication description =
+    let () =
+      if Hashtbl.mem all_features name then
+        failwithf "Feature '%s' is already declared." name
       in
-      let sub =
-        String.sub f 0 last_dot
+    let t =
+      {
+        name = name;
+        plugin = plugin;
+        publication = publication;
+        description = description;
+      }
       in
+    Hashtbl.add all_features name t;
+    t
+
+
+  let get_stage name =
         try
-          let last_slash =
-            String.rindex f '/'
-          in
-            if last_slash < last_dot then
-              sub
-            else
-              f
+      (Hashtbl.find all_features name).publication
         with Not_found ->
-          sub
+      failwithf (f_ "Feature %s doesn't exist.") name
+
+
+  let list () =
+    Hashtbl.fold (fun _ v acc -> v :: acc) all_features []
+
+  (*
+   * Real flags.
+   *)
+
+
+  let features =
+    create "features_fields"
+      (since_version "0.4")
+      (fun () ->
+         s_ "Enable to experiment not yet official features.")
+
+
+  let flag_docs =
+    create "flag_docs"
+      (since_version "0.3")
+      (fun () ->
+         s_ "Make building docs require '-docs' flag at configure.")
+
+
+  let flag_tests =
+    create "flag_tests"
+      (since_version "0.3")
+      (fun () ->
+         s_ "Make running tests require '-tests' flag at configure.")
 
-    with Not_found ->
-      f
 
-  let capitalize_file f =
-    let dir = dirname f in
-    let base = basename f in
-    concat dir (String.capitalize base)
+  let pack =
+    create "pack"
+      (since_version "0.3")
+      (fun () ->
+         s_ "Allow to create packed library.")
 
-  let uncapitalize_file f =
-    let dir = dirname f in
-    let base = basename f in
-    concat dir (String.uncapitalize base)
 
-end
+  let section_object =
+    create "section_object" beta
+      (fun () ->
+         s_ "Implement an object section.")
 
-module OASISHostPath = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISHostPath.ml" *)
 
+  let dynrun_for_release =
+    create "dynrun_for_release" alpha
+      (fun () ->
+         s_ "Make '-setup-update dynamic' suitable for releasing project.")
 
-  open Filename
 
-  module Unix = OASISUnixPath
+  let compiled_setup_ml =
+    create "compiled_setup_ml" alpha
+      (fun () ->
+         s_ "Compile the setup.ml and speed-up actions done with it.")
 
-  let make =
-    function
-      | [] ->
-          invalid_arg "OASISHostPath.make"
-      | hd :: tl ->
-          List.fold_left Filename.concat hd tl
+  let disable_oasis_section =
+    create "disable_oasis_section" alpha
+      (fun () ->
+         s_ "Allow the OASIS section comments and digests to be omitted in \
+             generated files.")
 
-  let of_unix ufn =
-    if Sys.os_type = "Unix" then
-      ufn
-    else
-      make
-        (List.map
-           (fun p ->
-              if p = Unix.current_dir_name then
-                current_dir_name
-              else if p = Unix.parent_dir_name then
-                parent_dir_name
-              else
-                p)
-           (OASISString.nsplit ufn '/'))
+  let no_automatic_syntax =
+    create "no_automatic_syntax" alpha
+      (fun () ->
+         s_ "Disable the automatic inclusion of -syntax camlp4o for packages \
+             that matches the internal heuristic (if a dependency ends with \
+             a .syntax or is a well known syntax).")
+
+  let findlib_directory =
+    create "findlib_directory" beta
+      (fun () ->
+         s_ "Allow to install findlib libraries in sub-directories of the target \
+            findlib directory.")
 
+  let findlib_extra_files =
+    create "findlib_extra_files" beta
+      (fun () ->
+         s_ "Allow to install extra files for findlib libraries.")
 
+  let source_patterns =
+    create "source_patterns" alpha
+      (fun () ->
+         s_ "Customize mapping between module name and source file.")
 end
 
 module OASISSection = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISSection.ml" *)
+(* # 22 "src/oasis/OASISSection.ml" *)
+
 
   open OASISTypes
 
@@ -1301,6 +2300,8 @@
     function
       | Library (cs, _, _) -> 
           `Library, cs
+      | Object (cs, _, _) ->
+        `Object, cs
       | Executable (cs, _, _) ->
           `Executable, cs
       | Flag (cs, _) ->
@@ -1318,6 +2321,7 @@
   let section_common_set cs =
     function
       | Library (_, bs, lib)     -> Library (cs, bs, lib)
+      | Object (_, bs, obj)      -> Object (cs, bs, obj)
       | Executable (_, bs, exec) -> Executable (cs, bs, exec)
       | Flag (_, flg)            -> Flag (cs, flg)
       | SrcRepo (_, src_repo)    -> SrcRepo (cs, src_repo)
@@ -1332,18 +2337,22 @@
     in
       k, cs.cs_name
 
-  let string_of_section sct =
-    let k, nm =
-      section_id sct
-    in
-      (match k with
+
+  let string_of_section_kind =
+    function
          | `Library    -> "library" 
+      | `Object     -> "object"
          | `Executable -> "executable"
          | `Flag       -> "flag"
          | `SrcRepo    -> "src repository"
          | `Test       -> "test"
-         | `Doc        -> "doc")
-      ^" "^nm
+      | `Doc        -> "doc"
+
+
+  let string_of_section sct =
+    let k, nm = section_id sct in
+    (string_of_section_kind k)^" "^nm
+
 
   let section_find id scts =
     List.find
@@ -1372,12 +2384,40 @@
 end
 
 module OASISBuildSection = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISBuildSection.ml" *)
+(* # 22 "src/oasis/OASISBuildSection.ml" *)
+
+  open OASISTypes
+
+  (* Look for a module file, considering capitalization or not. *)
+  let find_module source_file_exists bs modul =
+    let possible_lst =
+      OASISSourcePatterns.all_possible_files
+        (bs.bs_interface_patterns @ bs.bs_implementation_patterns)
+        ~path:bs.bs_path
+        ~modul
+    in
+    match List.filter source_file_exists possible_lst with
+    | (fn :: _) as fn_lst -> `Sources (OASISUnixPath.chop_extension fn, fn_lst)
+    | [] ->
+      let open OASISUtils in
+      let _, rev_lst =
+        List.fold_left
+          (fun (set, acc) fn ->
+             let base_fn = OASISUnixPath.chop_extension fn in
+             if SetString.mem base_fn set then
+               set, acc
+             else
+               SetString.add base_fn set, base_fn :: acc)
+          (SetString.empty, []) possible_lst
+      in
+      `No_sources (List.rev rev_lst)
+
 
 end
 
 module OASISExecutable = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISExecutable.ml" *)
+(* # 22 "src/oasis/OASISExecutable.ml" *)
+
 
   open OASISTypes
 
@@ -1408,80 +2450,33 @@
 end
 
 module OASISLibrary = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISLibrary.ml" *)
+(* # 22 "src/oasis/OASISLibrary.ml" *)
+
 
   open OASISTypes
-  open OASISUtils
   open OASISGettext
-  open OASISSection
-
-  type library_name = name
-  type findlib_part_name = name
-  type 'a map_of_findlib_part_name = 'a OASISUtils.MapString.t
-
-  exception InternalLibraryNotFound of library_name
-  exception FindlibPackageNotFound of findlib_name
-
-  type group_t =
-    | Container of findlib_name * group_t list
-    | Package of (findlib_name *
-                  common_section *
-                  build_section *
-                  library *
-                  group_t list)
 
-  (* Look for a module file, considering capitalization or not. *)
-  let find_module source_file_exists (cs, bs, lib) modul =
-    let possible_base_fn =
-      List.map
-        (OASISUnixPath.concat bs.bs_path)
-        [modul;
-         OASISUnixPath.uncapitalize_file modul;
-         OASISUnixPath.capitalize_file modul]
-    in
-      (* TODO: we should be able to be able to determine the source for every
-       * files. Hence we should introduce a Module(source: fn) for the fields
-       * Modules and InternalModules
-       *)
-      List.fold_left
-        (fun acc base_fn ->
-           match acc with
-             | `No_sources _ ->
-                 begin
-                   let file_found =
-                     List.fold_left
-                       (fun acc ext ->
-                          if source_file_exists (base_fn^ext) then
-                            (base_fn^ext) :: acc
-                          else
-                            acc)
-                       []
-                       [".ml"; ".mli"; ".mll"; ".mly"]
-                   in
-                     match file_found with
-                       | [] ->
-                           acc
-                       | lst ->
-                           `Sources (base_fn, lst)
-                 end
-             | `Sources _ ->
-                 acc)
-        (`No_sources possible_base_fn)
-        possible_base_fn
+  let find_module ~ctxt source_file_exists cs bs modul =
+    match OASISBuildSection.find_module source_file_exists bs modul with
+    | `Sources _ as res -> res
+    | `No_sources _ as res ->
+      OASISMessage.warning
+        ~ctxt
+        (f_ "Cannot find source file matching module '%s' in library %s.")
+        modul cs.cs_name;
+      OASISMessage.warning
+        ~ctxt
+        (f_ "Use InterfacePatterns or ImplementationPatterns to define \
+             this file with feature %S.")
+        (OASISFeatures.source_patterns.OASISFeatures.name);
+      res
 
   let source_unix_files ~ctxt (cs, bs, lib) source_file_exists =
     List.fold_left
       (fun acc modul ->
-         match find_module source_file_exists (cs, bs, lib) modul with
-           | `Sources (base_fn, lst) ->
-               (base_fn, lst) :: acc
-           | `No_sources _ ->
-               OASISMessage.warning
-                 ~ctxt
-                 (f_ "Cannot find source file matching \
-                      module '%s' in library %s")
-                 modul cs.cs_name;
-               acc)
+         match find_module ~ctxt source_file_exists cs bs modul with
+         | `Sources (base_fn, lst) -> (base_fn, lst) :: acc
+         | `No_sources _ -> acc)
       []
       (lib.lib_modules @ lib.lib_internal_modules)
 
@@ -1496,45 +2492,37 @@
 
     let find_modules lst ext = 
       let find_module modul =
-        match find_module source_file_exists (cs, bs, lib) modul with
-          | `Sources (base_fn, _) ->
-              [base_fn]
-          | `No_sources lst ->
-              OASISMessage.warning
-                ~ctxt
-                (f_ "Cannot find source file matching \
-                     module '%s' in library %s")
-                modul cs.cs_name;
-              lst
-      in
-      List.map 
-        (fun nm -> 
-           List.map 
-             (fun base_fn -> base_fn ^"."^ext)
-             (find_module nm))
-        lst
+        match find_module ~ctxt source_file_exists cs bs modul with
+        | `Sources (_, [fn]) when ext <> "cmi"
+                                     && Filename.check_suffix fn ".mli" ->
+          None (* No implementation files for pure interface. *)
+        | `Sources (base_fn, _) -> Some [base_fn]
+        | `No_sources lst -> Some lst
     in
-
-    (* The headers that should be compiled along *)
-    let headers =
-      if lib.lib_pack then
+      List.fold_left
+        (fun acc nm ->
+           match find_module nm with
+           | None -> acc
+           | Some base_fns ->
+             List.map (fun base_fn -> base_fn ^"."^ext) base_fns :: acc)
         []
-      else
-        find_modules
-          lib.lib_modules
-          "cmi"
+        lst
     in
 
     (* The .cmx that be compiled along *)
     let cmxs =
       let should_be_built =
-        (not lib.lib_pack) && (* Do not install .cmx packed submodules *)
         match bs.bs_compiled_object with
           | Native -> true
           | Best -> is_native
           | Byte -> false
       in
         if should_be_built then
+        if lib.lib_pack then
+          find_modules
+            [cs.cs_name]
+            "cmx"
+        else
           find_modules
             (lib.lib_modules @ lib.lib_internal_modules)
             "cmx"
@@ -1546,12 +2534,29 @@
       []
     in
 
+    (* The headers and annot/cmt files that should be compiled along *)
+    let headers =
+      let sufx =
+        if lib.lib_pack
+        then [".cmti"; ".cmt"; ".annot"]
+        else [".cmi"; ".cmti"; ".cmt"; ".annot"]
+      in
+      List.map
+        (List.fold_left
+           (fun accu s ->
+              let dot = String.rindex s '.' in
+              let base = String.sub s 0 dot in
+              List.map ((^) base) sufx @ accu)
+           [])
+        (find_modules lib.lib_modules "cmi")
+    in
+
     (* Compute what libraries should be built *)
     let acc_nopath =
       (* Add the packed header file if required *)
       let add_pack_header acc =
         if lib.lib_pack then
-          [cs.cs_name^".cmi"] :: acc
+          [cs.cs_name^".cmi"; cs.cs_name^".cmti"; cs.cs_name^".cmt"] :: acc
         else
           acc
       in
@@ -1568,26 +2573,23 @@
           [cs.cs_name^".cmxa"] :: [cs.cs_name^ext_lib] :: acc
       in
         match bs.bs_compiled_object with
-          | Native ->
-              byte (native acc_nopath)
-          | Best when is_native ->
-              byte (native acc_nopath)
-          | Byte | Best ->
-              byte acc_nopath
+      | Native -> byte (native acc_nopath)
+      | Best when is_native -> byte (native acc_nopath)
+      | Byte | Best -> byte acc_nopath
     in
 
     (* Add C library to be built *)
     let acc_nopath =
-      if bs.bs_c_sources <> [] then
-        begin
+      if bs.bs_c_sources <> [] then begin
           ["lib"^cs.cs_name^"_stubs"^ext_lib]
           ::
-          ["dll"^cs.cs_name^"_stubs"^ext_dll]
-          ::
-          acc_nopath
-        end
+        if has_native_dynlink then
+          ["dll"^cs.cs_name^"_stubs"^ext_dll] :: acc_nopath
       else
         acc_nopath
+      end else begin
+        acc_nopath
+      end
     in
 
       (* All the files generated *)
@@ -1598,7 +2600,110 @@
            acc_nopath)
         (headers @ cmxs)
 
-  type data = common_section * build_section * library
+
+end
+
+module OASISObject = struct
+(* # 22 "src/oasis/OASISObject.ml" *)
+
+
+  open OASISTypes
+  open OASISGettext
+
+
+  let find_module ~ctxt source_file_exists cs bs modul =
+    match OASISBuildSection.find_module source_file_exists bs modul with
+    | `Sources _ as res -> res
+    | `No_sources _ as res ->
+      OASISMessage.warning
+        ~ctxt
+        (f_ "Cannot find source file matching module '%s' in object %s.")
+        modul cs.cs_name;
+      OASISMessage.warning
+        ~ctxt
+        (f_ "Use InterfacePatterns or ImplementationPatterns to define \
+             this file with feature %S.")
+        (OASISFeatures.source_patterns.OASISFeatures.name);
+      res
+
+  let source_unix_files ~ctxt (cs, bs, obj) source_file_exists =
+    List.fold_left
+      (fun acc modul ->
+         match find_module ~ctxt source_file_exists cs bs modul with
+         | `Sources (base_fn, lst) -> (base_fn, lst) :: acc
+         | `No_sources _ -> acc)
+      []
+      obj.obj_modules
+
+
+  let generated_unix_files
+      ~ctxt
+      ~is_native
+      ~source_file_exists
+      (cs, bs, obj) =
+
+    let find_module ext modul =
+      match find_module ~ctxt source_file_exists cs bs modul with
+      | `Sources (base_fn, _) -> [base_fn ^ ext]
+      | `No_sources lst -> lst
+    in
+
+    let header, byte, native, c_object, f =
+      match obj.obj_modules with
+        | [ m ] -> (find_module ".cmi" m,
+            find_module ".cmo" m,
+            find_module ".cmx" m,
+            find_module ".o" m,
+            fun x -> x)
+        | _ -> ([cs.cs_name ^ ".cmi"],
+            [cs.cs_name ^ ".cmo"],
+            [cs.cs_name ^ ".cmx"],
+            [cs.cs_name ^ ".o"],
+            OASISUnixPath.concat bs.bs_path)
+    in
+    List.map (List.map f) (
+      match bs.bs_compiled_object with
+        | Native ->
+          native :: c_object :: byte :: header :: []
+        | Best when is_native ->
+          native :: c_object :: byte :: header :: []
+        | Byte | Best ->
+          byte :: header :: [])
+
+
+end
+
+module OASISFindlib = struct
+(* # 22 "src/oasis/OASISFindlib.ml" *)
+
+
+  open OASISTypes
+  open OASISUtils
+  open OASISGettext
+
+
+  type library_name = name
+  type findlib_part_name = name
+  type 'a map_of_findlib_part_name = 'a OASISUtils.MapString.t
+
+
+  exception InternalLibraryNotFound of library_name
+  exception FindlibPackageNotFound of findlib_name
+
+
+  type group_t =
+    | Container of findlib_name * group_t list
+    | Package of (findlib_name *
+                  common_section *
+                  build_section *
+                  [`Library of library | `Object of object_] *
+                  unix_dirname option *
+                  group_t list)
+
+
+  type data = common_section *
+      build_section *
+      [`Library of library | `Object of object_]
   type tree =
     | Node of (data option) * (tree MapString.t)
     | Leaf of data
@@ -1641,6 +2747,23 @@
                                mp
                    end
 
+             | Object (cs, _, obj) ->
+               begin
+                 let obj_name = cs.cs_name in
+                 if MapString.mem obj_name mp then
+                   failwithf
+                     (f_ "The object name '%s' is used more than once.")
+                     obj_name;
+                 let findlib_full_name = match obj.obj_findlib_fullname with
+                   | Some ns -> String.concat "." ns
+                   | None -> obj_name
+                 in
+                 MapString.add
+                   obj_name
+                   (`Solved findlib_full_name)
+                   mp
+               end
+
                | Executable _ | Test _ | Flag _ | SrcRepo _ | Doc _ ->
                    mp)
           MapString.empty
@@ -1708,7 +2831,7 @@
         let lib_name = cs.cs_name in
           findlib_name_of_library_name lib_name
       in
-      let rec add_children nm_lst (children : tree MapString.t) =
+      let rec add_children nm_lst (children: tree MapString.t) =
         match nm_lst with
           | (hd :: tl) ->
               begin
@@ -1757,17 +2880,31 @@
         add_children (OASISString.nsplit fndlb_fullname '.') mp
     in
 
-    let rec group_of_tree mp =
+    let unix_directory dn lib =
+      let directory =
+        match lib with
+        | `Library lib -> lib.lib_findlib_directory
+        | `Object obj -> obj.obj_findlib_directory
+      in
+      match dn, directory with
+      | None, None -> None
+      | None, Some dn | Some dn, None -> Some dn
+      | Some dn1, Some dn2 -> Some (OASISUnixPath.concat dn1 dn2)
+    in
+
+    let rec group_of_tree dn mp =
       MapString.fold
         (fun nm node acc ->
            let cur =
              match node with
                | Node (Some (cs, bs, lib), children) ->
-                   Package (nm, cs, bs, lib, group_of_tree children)
+               let current_dn = unix_directory dn lib in
+               Package (nm, cs, bs, lib, current_dn, group_of_tree current_dn children)
                | Node (None, children) ->
-                   Container (nm, group_of_tree children)
+               Container (nm, group_of_tree dn children)
                | Leaf (cs, bs, lib) ->
-                   Package (nm, cs, bs, lib, [])
+               let current_dn = unix_directory dn lib in
+               Package (nm, cs, bs, lib, current_dn, [])
            in
              cur :: acc)
         mp []
@@ -1778,25 +2915,25 @@
         (fun mp ->
            function
              | Library (cs, bs, lib) ->
-                 add (cs, bs, lib) mp
+               add (cs, bs, `Library lib) mp
+             | Object (cs, bs, obj) ->
+               add (cs, bs, `Object obj) mp
              | _ ->
                  mp)
         MapString.empty
         pkg.sections
     in
 
-    let groups =
-      group_of_tree group_mp
-    in
+    let groups = group_of_tree None group_mp in
 
     let library_name_of_findlib_name =
-      Lazy.lazy_from_fun
-        (fun () ->
+      lazy begin
            (* Revert findlib_name_of_library_name. *)
            MapString.fold
              (fun k v mp -> MapString.add v k mp)
              fndlb_name_of_lib_name
-             MapString.empty)
+          MapString.empty
+      end
     in
     let library_name_of_findlib_name fndlb_nm =
       try
@@ -1812,7 +2950,8 @@
   let findlib_of_group =
     function
       | Container (fndlb_nm, _)
-      | Package (fndlb_nm, _, _, _, _) -> fndlb_nm
+      | Package (fndlb_nm, _, _, _, _, _) -> fndlb_nm
+
 
   let root_of_group grp =
     let rec root_lib_aux =
@@ -1827,7 +2966,7 @@
                    res)
               None
               children
-        | Package (_, cs, bs, lib, _) ->
+        | Package (_, cs, bs, lib, _, _) ->
             Some (cs, bs, lib)
     in
       match root_lib_aux grp with
@@ -1841,56 +2981,255 @@
 end
 
 module OASISFlag = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISFlag.ml" *)
+(* # 22 "src/oasis/OASISFlag.ml" *)
+
 
 end
 
 module OASISPackage = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISPackage.ml" *)
+(* # 22 "src/oasis/OASISPackage.ml" *)
+
 
 end
 
 module OASISSourceRepository = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISSourceRepository.ml" *)
+(* # 22 "src/oasis/OASISSourceRepository.ml" *)
+
 
 end
 
 module OASISTest = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISTest.ml" *)
+(* # 22 "src/oasis/OASISTest.ml" *)
+
 
 end
 
 module OASISDocument = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISDocument.ml" *)
+(* # 22 "src/oasis/OASISDocument.ml" *)
+
 
 end
 
 module OASISExec = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISExec.ml" *)
+(* # 22 "src/oasis/OASISExec.ml" *)
+
 
   open OASISGettext
   open OASISUtils
   open OASISMessage
 
+  (* In general, there is no chance to quote properly with the current
+   * settings. ( This is only a problem, if BaseCustom.run is used (e.g
+   * test commands, PreConfigure,....). Most of the time, OASISExec.run
+   * is used with enabled quoting.)
+   *
+   * "$rm" should ideally expand to 'rm -f' (no quotes), but "$test_exec"
+   * should ideally expand to '"C:\Program Files\dir\test.exe"' (with
+   * quotes). Paths with spaces are common on Windows, so this problem
+   * can't be ignored.
+   *
+   * Using a command with additional parameters is quite useful, not only
+   * for trivial cases like $rm. You could add an additional parameter
+   * for $make in order to use a special compatibility mode, on windows
+   * you can use it to inform ocaml that a certain program is a shell
+   * script ('sh.exe pcre-config').
+   *
+   * An additional parameter (e.g. $rm_switches) would be ugly,
+   * especially for *nix users, who don't use space characters in their
+   * installation paths anyway.
+   *
+   * I use the following workaround, which should work most of the time:
+   *
+   * - if cmd doesn't contains spaces or other suspicious characters, it
+   * can be quoted in the usual way (not ambigous, I think)
+   *
+   * - if cmd does contain spaces, a file with this name exists, and the
+   * beginning of cmd looks like a absolute pathname
+   * ('\\test\dir\foo.exe' or "C:\\sa df\\foo.exe" - not "foo.exe" ), I
+   * will also quote it. (ambigous, there could be "C:\bin\rm.exe" and
+   * "C:\bin\rm -f.exe").  Relative filenames are not considered, because
+   * I assume the source code folder contains only well named files and
+   * relative paths like "../../make.exe" are uncommon (autoconf even
+   * rejects them) *)
+
+
+  (* stricter settings as for regular windows batch lines
+   * necessary because of shell comannds like:
+   *   LC_ALL=C make ....
+   *)
+  let is_dubious_char = function
+    | '+' | '~' | ':' | '.' | '-' | '_' | '/' | '\\' -> false
+    | c ->
+      OASISString.is_digit c = false &&
+      OASISString.is_alpha c = false
+
+
+  let win_quote_needed str =
+    let f = function
+      (* this list is not exhaustive. Feel free to added common chars, that
+       * can be passed to cmd.exe without quoting *)
+      | 'a' .. 'z'  | 'A' .. 'Z' | '0' .. '9'
+      | '_' | '-' | '~' | '.' | ':' | ',' | '\\' -> false
+      | _ -> true
+    in
+      str = "" || OASISString.exists f str
+
+  let is_simple_command str =
+    String.length str > 0 &&
+    not (OASISString.exists is_dubious_char str)
+
+  let is_path_sep = function
+    | '/' | '\\' -> true
+    | _ -> false
+
+  let starts_with_absolute_path cmd =
+    let len = String.length cmd in
+      if len < 3 then
+        false
+      else
+        let c0 = cmd.[0] in
+        let c1 = cmd.[1] in
+          if is_path_sep c0 && is_path_sep c1 then (* network devices: "//" *)
+            true
+          else if len = 3 then
+            false
+          else  (* C:\.... *)
+            OASISString.is_alpha c0 && c1 = ':' && is_path_sep cmd.[2]
+
+  let exe_exts = lazy
+    begin
+      let exts =
+        try
+          OASISString.nsplit
+            (Sys.getenv "PATHEXT")
+            ';'
+        with
+          | Not_found -> []
+      in
+      let exts' =
+        List.filter
+          ( fun a -> a <> "" && a.[0] = '.' && a <> ".exe" )
+          (List.map OASISString.lowercase_ascii exts) (* windows file system doesn't care *)
+      in
+        ".exe"::exts' (* .exe first, most common *)
+    end
+
+  let exe_file_exists fln =
+    Sys.file_exists fln ||
+    List.exists
+      (fun a -> Sys.file_exists ( fln ^ a ) )
+      (Lazy.force exe_exts)
+
+
+  let quote_anyway cmd =
+    if Sys.os_type <> "Win32" then (* workaround for windows only *)
+      false
+    else if is_simple_command cmd then
+      true
+    else
+      OASISString.exists OASISString.is_whitespace cmd &&
+        starts_with_absolute_path cmd &&
+        exe_file_exists cmd
+
+
+  let run_bash ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let fn = Filename.temp_file "oasis-" ".sh" in
+    let fn_deleted = ref false in
+      try
+        begin
+          let ch = open_out_bin fn in
+          let ch_closed = ref false in
+            try
+              begin
+                let cmd =
+                  if quote || quote_anyway cmd then
+                    OASISHostPath.quote (OASISHostPath.of_unix cmd)
+                  else
+                    cmd
+                in
+                  output_string ch cmd;
+                  List.iter
+                    ( fun s -> output_char ch ' '; output_string ch s )
+                    args ;
+                  output_char ch '\n';
+                  ch_closed:=true ;
+                  close_out ch;
+                  let bash = !OASISHostPath.bash_cmd () in
+                  let add_quotes = ref false in
+                  let shell_cmd =
+                    if Sys.os_type <> "Win32" then
+                      Filename.quote bash
+                    else
+                      if win_quote_needed bash = false then
+                        bash
+                      else
+                        begin
+                          add_quotes := true;
+                          Filename.quote bash
+                        end
+                  in
+                  let cmdline_orig = String.concat " " (cmd :: args) in
+                  let cmdline =
+                    let s = shell_cmd ^ " " ^ (Filename.quote fn) in
+                      if !add_quotes then
+                        "\"" ^ s ^ "\""
+                      else
+                        s
+                  in
+                    info ~ctxt (f_ "Running command '%s'") cmdline_orig;
+                    let ret = Sys.command cmdline in
+                      fn_deleted := true;
+                      Sys.remove fn;
+                      match f_exit_code, ret with
+                        | None, 0 -> ()
+                        | None, i ->
+                            failwithf
+                              (f_ "Command '%s' terminated with error code %d")
+                              cmdline_orig i
+                        | Some f, i ->
+                            f i
+              end
+            with
+              | x when !ch_closed = false ->
+                  close_out_noerr ch;
+                  raise x
+        end
+      with
+        | x when !fn_deleted = false ->
+            (try Sys.remove fn with _ -> () ) ;
+            raise x
+
   (* TODO: I don't like this quote, it is there because $(rm) foo expands to
    * 'rm -f' foo...
    *)
-  let run ~ctxt ?f_exit_code ?(quote=true) cmd args =
+  let run_default ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let add_quotes = ref false in
     let cmd =
-      if quote then
+      if quote || quote_anyway cmd then
         if Sys.os_type = "Win32" then
-          if String.contains cmd ' ' then
-            (* Double the 1st double quote... win32... sigh *)
-            "\""^(Filename.quote cmd)
-          else
+          begin
+            if win_quote_needed cmd = false then
             cmd
         else
+              begin
+                (* Double the 1st double quote... win32... sigh *)
+                (* Above comment ist false. The whole string must be quoted.
+                 * However, an error is only triggered, if args contains also
+                 * quoted parameters *)
+                add_quotes := true;
+                Filename.quote cmd
+              end
+          end
+        else
           Filename.quote cmd
       else
         cmd
     in
     let cmdline =
-      String.concat " " (cmd :: args)
+      let s = String.concat " " (cmd :: args) in
+        match !add_quotes with
+          | true -> "\"" ^ s ^ "\""
+          | false -> s
     in
       info ~ctxt (f_ "Running command '%s'") cmdline;
       match f_exit_code, Sys.command cmdline with
@@ -1902,6 +3241,14 @@
         | Some f, i ->
             f i
 
+  let run ~ctxt ?f_exit_code ?quote cmd args =
+    if OASISHostPath.use_bash () &&
+       (Sys.os_type <> "Win32" || not (Filename.check_suffix cmd ".bat"))
+    then
+      run_bash ~ctxt ?f_exit_code ?quote cmd args
+    else
+      run_default ~ctxt ?f_exit_code ?quote cmd args
+
   let run_read_output ~ctxt ?f_exit_code cmd args =
     let fn =
       Filename.temp_file "oasis-" ".txt"
@@ -1944,7 +3292,8 @@
 end
 
 module OASISFileUtil = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/oasis/OASISFileUtil.ml" *)
+(* # 22 "src/oasis/OASISFileUtil.ml" *)
+
 
   open OASISGettext
 
@@ -1969,7 +3320,7 @@
         (List.map
            (fun a ->
               List.map
-                (fun b -> a,b)
+                (fun b -> a, b)
                 lst2)
            lst1)
     in
@@ -1979,7 +3330,7 @@
         | p1 :: p2 :: tl ->
             let acc =
               (List.map
-                 (fun (a,b) -> Filename.concat a b)
+               (fun (a, b) -> Filename.concat a b)
                  (p1 * p2))
             in
               combined_paths (acc :: tl)
@@ -1991,21 +3342,23 @@
 
     let alternatives =
       List.map
-        (fun (p,e) ->
+        (fun (p, e) ->
            if String.length e > 0 && e.[0] <> '.' then
              p ^ "." ^ e
            else
              p ^ e)
         ((combined_paths paths) * exts)
     in
-      List.find
+    List.find (fun file ->
         (if case_sensitive then
-           file_exists_case
+         file_exists_case file
          else
-           Sys.file_exists)
-        alternatives
+         Sys.file_exists file)
+      && not (Sys.is_directory file)
+    ) alternatives
 
-  let which ~ctxt prg =
+
+  let which ?(plain=false) ?ctxt prg =
     let path_sep =
       match Sys.os_type with
         | "Win32" ->
@@ -2017,11 +3370,20 @@
     let exec_ext =
       match Sys.os_type with
         | "Win32" ->
-            "" :: (OASISString.nsplit (Sys.getenv "PATHEXT") path_sep)
+          "" :: (List.map
+                   OASISString.lowercase_ascii
+                   (OASISString.nsplit (Sys.getenv "PATHEXT") path_sep))
         | _ ->
             [""]
     in
+    let p =
       find_file ~case_sensitive:false [path_lst; [prg]] exec_ext
+    in
+    if plain then
+      p
+    else
+      OASISHostPath.of_unix p
+
 
   (**/**)
   let rec fix_dir dn =
@@ -2036,30 +3398,53 @@
       else
         dn
 
-  let q = Filename.quote
+
+  let q s = OASISHostPath.quote (OASISHostPath.of_unix s)
   (**/**)
 
   let cp ~ctxt ?(recurse=false) src tgt =
     if recurse then
-      match Sys.os_type with
-        | "Win32" ->
-            OASISExec.run ~ctxt
-              "xcopy" [q src; q tgt; "/E"]
-        | _ ->
-            OASISExec.run ~ctxt
-              "cp" ["-r"; q src; q tgt]
+      (*
+        'xcopy /E' and 'cp -r' don't have the same semantic!
+        -dir2 does exist:
+          xcopy dir dir2 /E -> copys content of dir into dir2 (dir2/dir doesn't exist!)
+          cp -r dir dir2    -> copys dir to dir2 (dir2/dir does exist!)
+        -dir2 doesn't exist:
+          xcopy dir dir2 /E -> request on command line, if dir2 is an directory or file.
+          cp -r dir dir2    -> dir and dir2 have the same content (dir2/dir doesn't exist)
+        Probably, there are even more differences,....
+      *)
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+        let tgt_real =
+          if Sys.file_exists tgt = false then
+            begin
+              OASISExec.run ~ctxt "md" [q tgt];
+              tgt
+            end
     else
-      OASISExec.run ~ctxt
-        (match Sys.os_type with
-         | "Win32" -> "copy"
-         | _ -> "cp")
-        [q src; q tgt]
+            let base = Filename.basename src in
+            if base = "." then
+              tgt
+            else
+              let tgt_real = Filename.concat tgt base in
+              if Sys.file_exists tgt_real = false then
+                OASISExec.run ~ctxt "md" [q tgt_real];
+              tgt_real
+        in
+        OASISExec.run ~ctxt "xcopy" [q src; q tgt_real; "/E" ; "/Q" ; "/Y"]
+      else
+        OASISExec.run ~ctxt "cp" ["-r"; q src; q tgt]
+    else if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+      OASISExec.run ~ctxt "copy" [q src; q tgt ; "/Y"]
+    else
+      OASISExec.run ~ctxt "cp" [q src; q tgt]
 
   let mkdir ~ctxt tgt =
     OASISExec.run ~ctxt
-      (match Sys.os_type with
-         | "Win32" -> "md"
-         | _ -> "mkdir")
+      ( if Sys.os_type = "Win32" && not (OASISHostPath.use_bash ()) then
+          "md"
+        else
+          "mkdir" )
       [q tgt]
 
   let rec mkdir_parent ~ctxt f tgt =
@@ -2084,16 +3469,20 @@
             end
         end
 
+
   let rmdir ~ctxt tgt =
-    if Sys.readdir tgt = [||] then
-      begin
-        match Sys.os_type with
-          | "Win32" ->
+    if Sys.readdir tgt = [||] then begin
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
               OASISExec.run ~ctxt "rd" [q tgt]
-          | _ ->
+      else
               OASISExec.run ~ctxt "rm" ["-r"; q tgt]
+    end else begin
+      OASISMessage.error ~ctxt
+        (f_ "Cannot remove directory '%s': not empty.")
+        tgt
       end
 
+
   let glob ~ctxt fn =
    let basename =
      Filename.basename fn
@@ -2139,9 +3528,10 @@
 end
 
 
-# 2142 "setup.ml"
+# 3531 "setup.ml"
 module BaseEnvLight = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseEnvLight.ml" *)
+(* # 22 "src/base/BaseEnvLight.ml" *)
+
 
   module MapString = Map.Make(String)
 
@@ -2145,25 +3535,16 @@
 
   module MapString = Map.Make(String)
 
+
   type t = string MapString.t
 
-  let default_filename =
-    Filename.concat
-      (Sys.getcwd ())
-      "setup.data"
 
-  let load ?(allow_empty=false) ?(filename=default_filename) () =
-    if Sys.file_exists filename then
-      begin
-        let chn =
-          open_in_bin filename
-        in
-        let st =
-          Stream.of_channel chn
-        in
-        let line =
-          ref 1
-        in
+  let default_filename = Filename.concat (Sys.getcwd ()) "setup.data"
+
+
+  let load ?(allow_empty=false) ?(filename=default_filename) ?stream () =
+    let line = ref 1 in
+    let lexer st =
         let st_line =
           Stream.from
             (fun _ ->
@@ -2173,52 +3554,45 @@
                    | c -> Some c
                with Stream.Failure -> None)
         in
-        let lexer =
           Genlex.make_lexer ["="] st_line
         in
-        let rec read_file mp =
-          match Stream.npeek 3 lexer with
+    let rec read_file lxr mp =
+      match Stream.npeek 3 lxr with
             | [Genlex.Ident nm; Genlex.Kwd "="; Genlex.String value] ->
-                Stream.junk lexer;
-                Stream.junk lexer;
-                Stream.junk lexer;
-                read_file (MapString.add nm value mp)
-            | [] ->
-                mp
+        Stream.junk lxr; Stream.junk lxr; Stream.junk lxr;
+        read_file lxr (MapString.add nm value mp)
+      | [] -> mp
             | _ ->
                 failwith
-                  (Printf.sprintf
-                     "Malformed data file '%s' line %d"
-                     filename !line)
-        in
-        let mp =
-          read_file MapString.empty
+          (Printf.sprintf "Malformed data file '%s' line %d" filename !line)
         in
-          close_in chn;
-          mp
-      end
-    else if allow_empty then
-      begin
+    match stream with
+    | Some st -> read_file (lexer st) MapString.empty
+    | None ->
+      if Sys.file_exists filename then begin
+        let chn = open_in_bin filename in
+        let st = Stream.of_channel chn in
+        try
+          let mp = read_file (lexer st) MapString.empty in
+          close_in chn; mp
+        with e ->
+          close_in chn; raise e
+      end else if allow_empty then begin
         MapString.empty
-      end
-    else
-      begin
+      end else begin
         failwith
           (Printf.sprintf
              "Unable to load environment, the file '%s' doesn't exist."
              filename)
       end
 
-  let var_get name env =
-    let rec var_expand str =
-      let buff =
-        Buffer.create ((String.length str) * 2)
-      in
+  let rec var_expand str env =
+    let buff = Buffer.create ((String.length str) * 2) in
         Buffer.add_substitute
           buff
           (fun var ->
              try
-               var_expand (MapString.find var env)
+           var_expand (MapString.find var env) env
              with Not_found ->
                failwith
                  (Printf.sprintf
@@ -2227,30 +3601,31 @@
                     str))
           str;
         Buffer.contents buff
-    in
-      var_expand (MapString.find name env)
 
-  let var_choose lst env =
-    OASISExpr.choose
-      (fun nm -> var_get nm env)
-      lst
+
+  let var_get name env = var_expand (MapString.find name env) env
+  let var_choose lst env = OASISExpr.choose (fun nm -> var_get nm env) lst
 end
 
 
-# 2240 "setup.ml"
+# 3611 "setup.ml"
 module BaseContext = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseContext.ml" *)
+(* # 22 "src/base/BaseContext.ml" *)
 
+  (* TODO: get rid of this module. *)
   open OASISContext
 
-  let args = args
+
+  let args () = fst (fspecs ())
+
 
   let default = default
 
 end
 
 module BaseMessage = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseMessage.ml" *)
+(* # 22 "src/base/BaseMessage.ml" *)
+
 
   (** Message to user, overrid for Base
       @author Sylvain Le Gall
@@ -2269,14 +3648,17 @@
 end
 
 module BaseEnv = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseEnv.ml" *)
+(* # 22 "src/base/BaseEnv.ml" *)
 
   open OASISGettext
   open OASISUtils
+  open OASISContext
   open PropList
 
+
   module MapString = BaseEnvLight.MapString
 
+
   type origin_t =
     | ODefault
     | OGetEnv
@@ -2299,22 +3683,23 @@
         group:      string option;
       }
 
-  let schema =
-    Schema.create "environment"
+
+  let schema = Schema.create "environment"
+
 
   (* Environment data *)
-  let env =
-    Data.create ()
+  let env = Data.create ()
+
 
   (* Environment data from file *)
-  let env_from_file =
-    ref MapString.empty
+  let env_from_file = ref MapString.empty
+
 
   (* Lexer for var *)
-  let var_lxr =
-    Genlex.make_lexer []
+  let var_lxr = Genlex.make_lexer []
 
-  let rec var_expand str =
+
+  let rec var_expand ?(quoted=false) str =
     let buff =
       Buffer.create ((String.length str) * 2)
     in
@@ -2342,7 +3727,11 @@
                  | [Genlex.Ident "ocaml_escaped"; Genlex.String s] ->
                      String.escaped s
                  | [Genlex.Ident nm] ->
-                     var_get nm
+                 let s = var_get nm in
+                 if quoted then
+                   OASISHostPath.quote s
+                 else
+                   s
                  | _ ->
                      failwithf
                        (f_ "Unknown expression '%s' in variable expansion of %s.")
@@ -2430,7 +3823,7 @@
     let var_get_low lst =
       let errors, res =
         List.fold_left
-          (fun (errors, res) (o, v) ->
+          (fun (errors, res) (_, v) ->
              if res = None then
                begin
                  try
@@ -2473,7 +3866,7 @@
         ~parse:(fun ?(context=ODefault) s -> [context, fun () -> s])
         ~print:var_get_low
         ~default
-        ~update:(fun ?context x old_x -> x @ old_x)
+        ~update:(fun ?context:_ x old_x -> x @ old_x)
         ?help
         extra
     in
@@ -2509,8 +3903,9 @@
           dflt
       end
 
-  let var_ignore (e : unit -> string) =
-    ()
+
+  let var_ignore (_: unit -> string) = ()
+
 
   let print_hidden =
     var_define
@@ -2532,37 +3928,58 @@
          []
          schema)
 
-  let default_filename =
-    BaseEnvLight.default_filename
 
-  let load ?allow_empty ?filename () =
-    env_from_file := BaseEnvLight.load ?allow_empty ?filename ()
+  let default_filename = in_srcdir "setup.data"
+
+
+  let load ~ctxt ?(allow_empty=false) ?(filename=default_filename) () =
+    let open OASISFileSystem in
+    env_from_file :=
+      let repr_filename = ctxt.srcfs#string_of_filename filename in
+      if ctxt.srcfs#file_exists filename then begin
+        let buf = Buffer.create 13 in
+        defer_close
+          (ctxt.srcfs#open_in ~mode:binary_in filename)
+          (read_all buf);
+        defer_close
+          (ctxt.srcfs#open_in ~mode:binary_in filename)
+          (fun rdr ->
+             OASISMessage.info ~ctxt "Loading environment from %S." repr_filename;
+             BaseEnvLight.load ~allow_empty
+               ~filename:(repr_filename)
+               ~stream:(stream_of_reader rdr)
+               ())
+      end else if allow_empty then begin
+        BaseEnvLight.MapString.empty
+      end else begin
+        failwith
+          (Printf.sprintf
+             (f_ "Unable to load environment, the file '%s' doesn't exist.")
+             repr_filename)
+      end
+
 
   let unload () =
     env_from_file := MapString.empty;
     Data.clear env
 
-  let dump ?(filename=default_filename) () =
-    let chn =
-      open_out_bin filename
-    in
+
+  let dump ~ctxt ?(filename=default_filename) () =
+    let open OASISFileSystem in
+    defer_close
+      (ctxt.OASISContext.srcfs#open_out ~mode:binary_out filename)
+      (fun wrtr ->
+         let buf = Buffer.create 63 in
     let output nm value = 
-      Printf.fprintf chn "%s=%S\n" nm value
+           Buffer.add_string buf (Printf.sprintf "%s=%S\n" nm value)
     in
     let mp_todo = 
       (* Dump data from schema *)
       Schema.fold
         (fun mp_todo nm def _ ->
-           if def.dump then
-             begin
+                if def.dump then begin
                try
-                 let value =
-                   Schema.get
-                     schema
-                     env
-                     nm
-                 in
-                   output nm value
+                    output nm (Schema.get schema env nm)
                with Not_set _ ->
                  ()
              end;
@@ -2572,9 +3989,7 @@
     in
       (* Dump data defined outside of schema *)
       MapString.iter output mp_todo;
-
-      (* End of the dump *)
-      close_out chn
+         wrtr#output buf)
 
   let print () =
     let printable_vars =
@@ -2583,12 +3998,7 @@
            if not def.hide || bool_of_string (print_hidden ()) then
              begin
                try
-                 let value =
-                   Schema.get
-                     schema
-                     env
-                     nm
-                 in
+                 let value = Schema.get schema env nm in
                  let txt =
                    match short_descr_opt with
                      | Some s -> s ()
@@ -2608,14 +4018,15 @@
         (List.rev_map String.length
            (List.rev_map fst printable_vars))
     in
-    let dot_pad str =
-      String.make ((max_length - (String.length str)) + 3) '.'
-    in
-
-    Printf.printf "\nConfiguration: \n";
+    let dot_pad str = String.make ((max_length - (String.length str)) + 3) '.' in
+    Printf.printf "\nConfiguration:\n";
     List.iter
-      (fun (name,value) ->
-        Printf.printf "%s: %s %s\n" name (dot_pad name) value)
+      (fun (name, value) ->
+         Printf.printf "%s: %s" name (dot_pad name);
+         if value = "" then
+           Printf.printf "\n"
+         else
+           Printf.printf " %s\n" value)
       (List.rev printable_vars);
     Printf.printf "\n%!"
 
@@ -2619,10 +4030,9 @@
       (List.rev printable_vars);
     Printf.printf "\n%!"
 
+
   let args () =
-    let arg_concat =
-      OASISUtils.varname_concat ~hyphen:'-'
-    in
+    let arg_concat = OASISUtils.varname_concat ~hyphen:'-' in
       [
         "--override",
          Arg.Tuple
@@ -2729,7 +4139,8 @@
 end
 
 module BaseArgExt = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseArgExt.ml" *)
+(* # 22 "src/base/BaseArgExt.ml" *)
+
 
   open OASISUtils
   open OASISGettext
@@ -2757,7 +4169,8 @@
 end
 
 module BaseCheck = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseCheck.ml" *)
+(* # 22 "src/base/BaseCheck.ml" *)
+
 
   open BaseEnv
   open BaseMessage
@@ -2849,9 +4269,11 @@
     in
     let findlib_dir pkg =
       let dir =
+        OASISHostPath.of_unix (
+          OASISHostPath.ocamlfind_unquote (
         OASISExec.run_read_one_line ~ctxt:!BaseContext.default
           (ocamlfind ())
-          ["query"; "-format"; "%d"; pkg]
+              ["query"; "-format"; "%d"; pkg] ) )
       in
         if Sys.file_exists dir && Sys.is_directory dir then
           dir
@@ -2883,7 +4305,7 @@
 end
 
 module BaseOCamlcConfig = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseOCamlcConfig.ml" *)
+(* # 22 "src/base/BaseOCamlcConfig.ml" *)
 
 
   open BaseEnv
@@ -2977,6 +4403,9 @@
       match nm with
         | "ocaml_version" -> 
             "version", chop_version_suffix
+        | "standard_library"
+        | "standard_library_default" ->
+            nm, ( fun x -> OASISHostPath.of_unix x)
         | _ -> nm, (fun x -> x)
     in
       var_redefine
@@ -2999,12 +4428,11 @@
 end
 
 module BaseStandardVar = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseStandardVar.ml" *)
+(* # 22 "src/base/BaseStandardVar.ml" *)
 
 
   open OASISGettext
   open OASISTypes
-  open OASISExpr
   open BaseCheck
   open BaseEnv
 
@@ -3101,26 +4543,76 @@
       name
       dflt
 
+
   let (/) a b =
-    if os_type () = Sys.os_type then
+    let os = os_type () in
+    if os = Sys.os_type then
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () then
+        OASISUnixPath.concat a b
+      else
       Filename.concat a b
-    else if os_type () = "Unix" then
+    else if os = "Unix" || os = "Cygwin" then
       OASISUnixPath.concat a b
     else
-      OASISUtils.failwithf (f_ "Cannot handle os_type %s filename concat")
-        (os_type ())
+      OASISUtils.failwithf (f_ "Cannot handle os_type %s filename concat") os
   (**/**)
 
+  let auto_bash =
+    lazy (
+      try
+        let bash = OASISFileUtil.which ~plain:true "bash" in
+        let sh = Filename.concat (Filename.dirname bash) "sh.exe" in
+        if Sys.file_exists sh then
+          sh
+        else
+          bash
+      with
+      | Not_found | Sys_error _ -> "" )
+
+  let auto_bash () =
+    if Sys.os_type <> "Win32" then
+      ""
+    else
+      Lazy.force auto_bash
+
+  let bash_cmd =
+    var_define
+     ~short_desc:(fun () -> s_ "Enforced bash shell:")
+      ~cli:CLIAuto
+      ~arg_help:"program"
+      "use_bash"
+      auto_bash
+
   let prefix =
     p "prefix"
       (fun () -> s_ "Install architecture-independent files dir")
       (fun () ->
          match os_type () with
            | "Win32" ->
+            let getenv w =
+              try
+                Some(Sys.getenv w)
+              with
+              | Not_found -> None
+            in
+            let s =
+              if Sys.word_size = 64 then
+                getenv "ProgramW6432"
+              else
+                None
+            in
+            let s =
+              if s = None then
+                getenv "PROGRAMFILES"
+              else
+                s
+            in
                let program_files =
-                 Sys.getenv "PROGRAMFILES"
+              match s with
+              | None -> "C:\\Program Files"
+              | Some x -> x
                in
-                 program_files/(pkg_name ())
+            OASISHostPath.of_unix (program_files/(pkg_name ()))
            | _ ->
                "/usr/local")
 
@@ -3192,7 +4698,16 @@
   let docdir =
     p "docdir"
       (fun () -> s_ "Documentation root")
-      (fun () -> "$datarootdir"/"doc"/"$pkg_name")
+      (fun () ->
+        (* TODO: (Windows only?) "$pkg_name" is not always substituted
+         * (at least if datarootdir contains spaces or other garbage)
+         * I haven't looked up why.
+         *)
+        match os_type () with
+          | "Win32" -> "$datarootdir"/"doc"/ ( pkg_name () )
+          | _ -> "$datarootdir"/"doc"/"$pkg_name"
+      )
+
 
   let htmldir =
     p "htmldir"
@@ -3234,12 +4755,12 @@
       "is_native"
       (fun () ->
          try
-           let _s : string =
+           let _s: string =
              ocamlopt ()
            in
              "true"
          with PropList.Not_set _ ->
-           let _s : string =
+           let _s: string =
              ocamlc ()
            in
              "false")
@@ -3249,9 +4771,10 @@
       "suffix_program"
       (fun () ->
          match os_type () with
-           | "Win32" -> ".exe"
+           | "Win32" | "Cygwin" -> ".exe"
            | _ -> "")
 
+
   let rm =
     var_define
       ~short_desc:(fun () -> s_ "Remove a file.")
@@ -3257,18 +4780,22 @@
       ~short_desc:(fun () -> s_ "Remove a file.")
       "rm"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "del"
-           | _ -> "rm -f")
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "del"
+         else
+           "rm -f" )
+
 
   let rmdir =
     var_define
       ~short_desc:(fun () -> s_ "Remove a directory.")
       "rmdir"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "rd"
-           | _ -> "rm -rf")
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "rd"
+         else
+           "rm -rf")
+
 
   let debug =
     var_define
@@ -3327,14 +4858,26 @@
            let has_native_dynlink = 
              let ocamlfind = ocamlfind () in
                try
-                 let fn =
+               (* -format %d/%a doesn't work, because ocamlfind quotes %d
+                  * and %a separatly *)
+               let fn1 =
+                 OASISHostPath.ocamlfind_unquote (
+                   OASISExec.run_read_one_line
+                     ~ctxt:!BaseContext.default
+                     ocamlfind
+                     ["query"; "-predicates"; "native"; "dynlink";
+                      "-format"; "%d"] )
+               in
+               let fn2 =
+                 OASISHostPath.ocamlfind_unquote (
                    OASISExec.run_read_one_line
                      ~ctxt:!BaseContext.default
                      ocamlfind
                      ["query"; "-predicates"; "native"; "dynlink";
-                      "-format"; "%d/%a"]
+                      "-format"; "%a"]
+                 )
                  in
-                   Sys.file_exists fn
+               fn1 <> "" && fn2 <> "" && Sys.file_exists (Filename.concat fn1 fn2)
                with _ ->
                  false
            in
@@ -3360,67 +4904,57 @@
     rpkg := Some pkg;
     List.iter (fun f -> f pkg.oasis_version) !var_cond
 
+  let () =
+    OASISHostPath.bash_cmd := bash_cmd
 end
 
 module BaseFileAB = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseFileAB.ml" *)
+(* # 22 "src/base/BaseFileAB.ml" *)
+
 
   open BaseEnv
   open OASISGettext
   open BaseMessage
+  open OASISContext
+
 
   let to_filename fn =
-    let fn =
-      OASISHostPath.of_unix fn
-    in
       if not (Filename.check_suffix fn ".ab") then
-        warning
-          (f_ "File '%s' doesn't have '.ab' extension")
-          fn;
-      Filename.chop_extension fn
+      warning (f_ "File '%s' doesn't have '.ab' extension") fn;
+    OASISFileSystem.of_unix_filename (Filename.chop_extension fn)
 
-  let replace fn_lst =
-    let buff =
-      Buffer.create 13
-    in
+
+  let replace ~ctxt fn_lst =
+    let open OASISFileSystem in
+    let ibuf, obuf = Buffer.create 13, Buffer.create 13 in
       List.iter
         (fun fn ->
-           let fn =
-             OASISHostPath.of_unix fn
-           in
-           let chn_in =
-             open_in fn
-           in
-           let chn_out =
-             open_out (to_filename fn)
-           in
-             (
-               try
-                 while true do
-                  Buffer.add_string buff (var_expand (input_line chn_in));
-                  Buffer.add_char buff '\n'
-                 done
-               with End_of_file ->
-                 ()
-             );
-             Buffer.output_buffer chn_out buff;
-             Buffer.clear buff;
-             close_in chn_in;
-             close_out chn_out)
+         Buffer.clear ibuf; Buffer.clear obuf;
+         defer_close
+           (ctxt.srcfs#open_in (of_unix_filename fn))
+           (read_all ibuf);
+         Buffer.add_string obuf (var_expand (Buffer.contents ibuf));
+         defer_close
+           (ctxt.srcfs#open_out (to_filename fn))
+           (fun wrtr -> wrtr#output obuf))
         fn_lst
 end
 
 module BaseLog = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseLog.ml" *)
+(* # 22 "src/base/BaseLog.ml" *)
+
 
   open OASISUtils
+  open OASISContext
+  open OASISGettext
+  open OASISFileSystem
 
-  let default_filename =
-    Filename.concat
-      (Filename.dirname BaseEnv.default_filename)
-      "setup.log"
 
-  module SetTupleString =
+  let default_filename = in_srcdir "setup.log"
+
+
+  let load ~ctxt () =
+    let module SetTupleString =
     Set.Make
       (struct
          type t = string * string
@@ -3429,108 +4963,79 @@
              | 0 -> String.compare s12 s22
              | n -> n
        end)
-
-  let load () =
-    if Sys.file_exists default_filename then
-      begin
-        let chn =
-          open_in default_filename
-        in
-        let scbuf =
-          Scanf.Scanning.from_file default_filename
         in
+    if ctxt.srcfs#file_exists default_filename then begin
+      defer_close
+        (ctxt.srcfs#open_in default_filename)
+        (fun rdr ->
+           let line = ref 1 in
+           let lxr = Genlex.make_lexer [] (stream_of_reader rdr) in
         let rec read_aux (st, lst) =
-          if not (Scanf.Scanning.end_of_input scbuf) then
-            begin
-              let acc =
-                try
-                  Scanf.bscanf scbuf "%S %S\n"
-                    (fun e d ->
-                       let t =
-                         e, d
-                       in
+             match Stream.npeek 2 lxr with
+             | [Genlex.String e; Genlex.String d] ->
+               let t = e, d in
+               Stream.junk lxr; Stream.junk lxr;
                          if SetTupleString.mem t st then
-                           st, lst
-                         else
-                           SetTupleString.add t st,
-                           t :: lst)
-                with Scanf.Scan_failure _ ->
-                  failwith
-                    (Scanf.bscanf scbuf
-                       "%l"
-                       (fun line ->
-                          Printf.sprintf
-                            "Malformed log file '%s' at line %d"
-                            default_filename
-                            line))
-              in
-                read_aux acc
-            end
+                 read_aux (st, lst)
           else
-            begin
-              close_in chn;
-              List.rev lst
-            end
+                 read_aux (SetTupleString.add t st, t :: lst)
+             | [] -> List.rev lst
+             | _ ->
+               failwithf
+                 (f_ "Malformed log file '%s' at line %d")
+                 (ctxt.srcfs#string_of_filename default_filename)
+                 !line
         in
-          read_aux (SetTupleString.empty, [])
-      end
-    else
-      begin
+           read_aux (SetTupleString.empty, []))
+    end else begin
         []
       end
 
-  let register event data =
-    let chn_out =
-      open_out_gen [Open_append; Open_creat; Open_text] 0o644 default_filename
-    in
-      Printf.fprintf chn_out "%S %S\n" event data;
-      close_out chn_out
 
-  let unregister event data =
-    if Sys.file_exists default_filename then
-      begin
-        let lst =
-          load ()
-        in
-        let chn_out =
-          open_out default_filename
-        in
-        let write_something =
-          ref false
-        in
+  let register ~ctxt event data =
+    defer_close
+      (ctxt.srcfs#open_out
+         ~mode:[Open_append; Open_creat; Open_text]
+         ~perm:0o644
+         default_filename)
+      (fun wrtr ->
+         let buf = Buffer.create 13 in
+         Printf.bprintf buf "%S %S\n" event data;
+         wrtr#output buf)
+
+
+  let unregister ~ctxt event data =
+    let lst = load ~ctxt () in
+    let buf = Buffer.create 13 in
           List.iter
             (fun (e, d) ->
                if e <> event || d <> data then
-                 begin
-                   write_something := true;
-                   Printf.fprintf chn_out "%S %S\n" e d
-                 end)
+           Printf.bprintf buf "%S %S\n" e d)
             lst;
-          close_out chn_out;
-          if not !write_something then
-            Sys.remove default_filename
-      end
+    if Buffer.length buf > 0 then
+      defer_close
+        (ctxt.srcfs#open_out default_filename)
+        (fun wrtr -> wrtr#output buf)
+    else
+      ctxt.srcfs#remove default_filename
 
-  let filter events =
-    let st_events =
-      List.fold_left
-        (fun st e ->
-           SetString.add e st)
-        SetString.empty
-        events
-    in
+
+  let filter ~ctxt events =
+    let st_events = SetString.of_list events in
       List.filter
         (fun (e, _) -> SetString.mem e st_events)
-        (load ())
+      (load ~ctxt ())
 
-  let exists event data =
+
+  let exists ~ctxt event data =
     List.exists
       (fun v -> (event, data) = v)
-      (load ())
+      (load ~ctxt ())
 end
 
 module BaseBuilt = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseBuilt.ml" *)
+(* # 22 "src/base/BaseBuilt.ml" *)
+
 
   open OASISTypes
   open OASISGettext
@@ -3541,8 +5047,10 @@
     | BExec    (* Executable *)
     | BExecLib (* Library coming with executable *)
     | BLib     (* Library *)
+    | BObj     (* Library *)
     | BDoc     (* Document *)
 
+
   let to_log_event_file t nm =
     "built_"^
     (match t with
@@ -3549,6 +5057,7 @@
        | BExec -> "exec"
        | BExecLib -> "exec_lib"
        | BLib -> "lib"
+        | BObj -> "obj"
        | BDoc -> "doc")^
     "_"^nm
 
@@ -3555,27 +5065,25 @@
   let to_log_event_done t nm =
     "is_"^(to_log_event_file t nm)
 
-  let register t nm lst =
-    BaseLog.register
-      (to_log_event_done t nm)
-      "true";
+
+  let register ~ctxt t nm lst =
+    BaseLog.register ~ctxt (to_log_event_done t nm) "true";
     List.iter
       (fun alt ->
          let registered =
            List.fold_left
              (fun registered fn ->
-                if OASISFileUtil.file_exists_case fn then
-                  begin
-                    BaseLog.register
+                if OASISFileUtil.file_exists_case fn then begin
+                  BaseLog.register ~ctxt
                       (to_log_event_file t nm)
                       (if Filename.is_relative fn then
                          Filename.concat (Sys.getcwd ()) fn
                        else
                          fn);
                     true
-                  end
-                else
-                  registered)
+                end else begin
+                  registered
+                end)
              false
              alt
          in
@@ -3585,52 +5093,42 @@
                (String.concat (s_ ", ") alt))
       lst
 
-  let unregister t nm =
+
+  let unregister ~ctxt t nm =
     List.iter
-      (fun (e, d) ->
-         BaseLog.unregister e d)
-      (BaseLog.filter
-         [to_log_event_file t nm;
-          to_log_event_done t nm])
+      (fun (e, d) -> BaseLog.unregister ~ctxt e d)
+      (BaseLog.filter ~ctxt [to_log_event_file t nm; to_log_event_done t nm])
 
-  let fold t nm f acc =
+
+  let fold ~ctxt t nm f acc =
     List.fold_left
       (fun acc (_, fn) ->
-         if OASISFileUtil.file_exists_case fn then
-           begin
+         if OASISFileUtil.file_exists_case fn then begin
              f acc fn
-           end
-         else
-           begin
+         end else begin
              warning
                (f_ "File '%s' has been marked as built \
                   for %s but doesn't exist")
                fn
                (Printf.sprintf
                   (match t with
-                     | BExec | BExecLib ->
-                         (f_ "executable %s")
-                     | BLib ->
-                         (f_ "library %s")
-                     | BDoc ->
-                         (f_ "documentation %s"))
+                  | BExec | BExecLib -> (f_ "executable %s")
+                  | BLib -> (f_ "library %s")
+                  | BObj -> (f_ "object %s")
+                  | BDoc -> (f_ "documentation %s"))
                   nm);
              acc
            end)
       acc
-      (BaseLog.filter
-         [to_log_event_file t nm])
+      (BaseLog.filter ~ctxt [to_log_event_file t nm])
+
 
-  let is_built t nm =
+  let is_built ~ctxt t nm =
     List.fold_left
-      (fun is_built (_, d) ->
-         (try
-            bool_of_string d
-          with _ ->
-            false))
+      (fun _ (_, d) -> try bool_of_string d with _ -> false)
       false
-      (BaseLog.filter
-         [to_log_event_done t nm])
+      (BaseLog.filter ~ctxt [to_log_event_done t nm])
+
 
   let of_executable ffn (cs, bs, exec) =
     let unix_exec_is, unix_dll_opt =
@@ -3674,10 +5173,28 @@
     in
       evs, unix_lst
 
+
+  let of_object ffn (cs, bs, obj) =
+    let unix_lst =
+      OASISObject.generated_unix_files
+        ~ctxt:!BaseContext.default
+        ~source_file_exists:(fun fn ->
+          OASISFileUtil.file_exists_case (OASISHostPath.of_unix fn))
+        ~is_native:(bool_of_string (is_native ()))
+        (cs, bs, obj)
+    in
+    let evs =
+      [BObj,
+       cs.cs_name,
+       List.map (List.map ffn) unix_lst]
+    in
+    evs, unix_lst
+
 end
 
 module BaseCustom = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseCustom.ml" *)
+(* # 22 "src/base/BaseCustom.ml" *)
+
 
   open BaseEnv
   open BaseMessage
@@ -3688,9 +5206,10 @@
     OASISExec.run ~ctxt:!BaseContext.default ~quote:false
       (var_expand cmd)
       (List.map
-         var_expand
+         (var_expand ~quoted:true)
          (args @ (Array.to_list extra_args)))
 
+
   let hook ?(failsafe=false) cstm f e =
     let optional_command lst =
       let printer =
@@ -3727,7 +5246,7 @@
 end
 
 module BaseDynVar = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseDynVar.ml" *)
+(* # 22 "src/base/BaseDynVar.ml" *)
 
 
   open OASISTypes
@@ -3735,12 +5254,13 @@
   open BaseEnv
   open BaseBuilt
 
-  let init pkg =
+
+  let init ~ctxt pkg =
     (* TODO: disambiguate exec vs other variable by adding exec_VARNAME. *)
     (* TODO: provide compile option for library libary_byte_args_VARNAME... *)
     List.iter
       (function
-         | Executable (cs, bs, exec) ->
+        | Executable (cs, bs, _) ->
              if var_choose bs.bs_build then
                var_ignore
                  (var_redefine
@@ -3753,10 +5273,7 @@
                     (OASISUtils.varname_of_string cs.cs_name)
                     (fun () ->
                        let fn_opt =
-                         fold
-                           BExec cs.cs_name
-                           (fun _ fn -> Some fn)
-                           None
+                      fold ~ctxt BExec cs.cs_name (fun _ fn -> Some fn) None
                        in
                          match fn_opt with
                            | Some fn -> fn
@@ -3768,21 +5285,22 @@
                                              (f_ "Executable '%s' not yet built.")
                                              cs.cs_name)))))
 
-         | Library _ | Flag _ | Test _ | SrcRepo _ | Doc _ ->
+        | Library _ | Object _ | Flag _ | Test _ | SrcRepo _ | Doc _ ->
              ())
       pkg.sections
 end
 
 module BaseTest = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseTest.ml" *)
+(* # 22 "src/base/BaseTest.ml" *)
+
 
   open BaseEnv
   open BaseMessage
   open OASISTypes
-  open OASISExpr
   open OASISGettext
 
-  let test lst pkg extra_args =
+
+  let test ~ctxt lst pkg extra_args =
 
     let one_test (failure, n) (test_plugin, cs, test) =
       if var_choose
@@ -3792,15 +5310,11 @@
            ~printer:string_of_bool
            test.test_run then
         begin
-          let () =
-            info (f_ "Running test '%s'") cs.cs_name
-          in
+          let () = info (f_ "Running test '%s'") cs.cs_name in
           let back_cwd =
             match test.test_working_directory with
               | Some dir ->
-                  let cwd =
-                    Sys.getcwd ()
-                  in
+                let cwd = Sys.getcwd () in
                   let chdir d =
                     info (f_ "Changing directory to '%s'") d;
                     Sys.chdir d
@@ -3815,7 +5329,7 @@
               let failure_percent =
                 BaseCustom.hook
                   test.test_custom
-                  (test_plugin pkg (cs, test))
+                (test_plugin ~ctxt pkg (cs, test))
                   extra_args
               in
                 back_cwd ();
@@ -3832,18 +5346,8 @@
           (failure, n)
         end
     in
-    let (failed, n) =
-      List.fold_left
-        one_test
-        (0.0, 0)
-        lst
-    in
-    let failure_percent =
-      if n = 0 then
-        0.0
-      else
-        failed /. (float_of_int n)
-    in
+    let failed, n = List.fold_left one_test (0.0, 0) lst in
+    let failure_percent = if n = 0 then 0.0 else failed /. (float_of_int n) in
     let msg =
       Printf.sprintf
         (f_ "Tests had a %.2f%% failure rate")
@@ -3855,7 +5359,7 @@
         info "%s" msg;
 
       (* Possible explanation why the tests where not run. *)
-      if OASISVersion.version_0_3_or_after pkg.oasis_version &&
+    if OASISFeatures.package_test OASISFeatures.flag_tests pkg &&
          not (bool_of_string (BaseStandardVar.tests ())) &&
          lst <> [] then
         BaseMessage.warning
@@ -3864,14 +5368,16 @@
 end
 
 module BaseDoc = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseDoc.ml" *)
+(* # 22 "src/base/BaseDoc.ml" *)
+
 
   open BaseEnv
   open BaseMessage
   open OASISTypes
   open OASISGettext
 
-  let doc lst pkg extra_args =
+
+  let doc ~ctxt lst pkg extra_args =
 
     let one_doc (doc_plugin, cs, doc) =
       if var_choose
@@ -3884,13 +5390,13 @@
           info (f_ "Building documentation '%s'") cs.cs_name;
           BaseCustom.hook
             doc.doc_custom
-            (doc_plugin pkg (cs, doc))
+            (doc_plugin ~ctxt pkg (cs, doc))
             extra_args
         end
     in
       List.iter one_doc lst;
 
-      if OASISVersion.version_0_3_or_after pkg.oasis_version &&
+    if OASISFeatures.package_test OASISFeatures.flag_docs pkg &&
          not (bool_of_string (BaseStandardVar.docs ())) &&
          lst <> [] then
         BaseMessage.warning
@@ -3899,12 +5405,12 @@
 end
 
 module BaseSetup = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/base/BaseSetup.ml" *)
+(* # 22 "src/base/BaseSetup.ml" *)
 
+  open OASISContext
   open BaseEnv
   open BaseMessage
   open OASISTypes
-  open OASISSection
   open OASISGettext
   open OASISUtils
 
@@ -3908,11 +5414,19 @@
   open OASISGettext
   open OASISUtils
 
+
   type std_args_fun =
-      package -> string array -> unit
+    ctxt:OASISContext.t -> package -> string array -> unit
+
 
   type ('a, 'b) section_args_fun =
-      name * (package -> (common_section * 'a) -> string array -> 'b)
+    name *
+    (ctxt:OASISContext.t ->
+     package ->
+     (common_section * 'a) ->
+     string array ->
+     'b)
+
 
   type t =
       {
@@ -3961,45 +5477,67 @@
         nm
         action
 
-  let configure t args =
+
+  let configure ~ctxt t args =
     (* Run configure *)
+
+    (* use-bash is an exception. It's already needed to run the
+       pre-configure script. *)
+    let rec f = function
+      | [] ->
+        begin
+          try
+            let x = Sys.getenv "USE_BASH" in
+              OASISHostPath.bash_cmd := (fun () -> x);
+          with
+            _ -> ()
+        end
+      | "--use-bash"::x::_ ->
+          OASISHostPath.bash_cmd := (fun () -> x);
+      | _::tl -> f tl
+    in
+      f (Array.to_list args);
     BaseCustom.hook
       t.package.conf_custom
       (fun () -> 
+           OASISHostPath.bash_cmd := BaseStandardVar.bash_cmd;
          (* Reload if preconf has changed it *)
          begin
            try
              unload ();
-             load ();
+             load ~ctxt ();
            with _ ->
              ()
          end;
 
          (* Run plugin's configure *)
-         t.configure t.package args;
+         t.configure ~ctxt t.package args;
 
          (* Dump to allow postconf to change it *)
-         dump ())
+         dump ~ctxt ())
       ();
 
     (* Reload environment *)
     unload ();
-    load ();
+    load ~ctxt ();
 
     (* Save environment *)
     print ();
 
     (* Replace data in file *)
-    BaseFileAB.replace t.package.files_ab
+    BaseFileAB.replace ~ctxt t.package.files_ab
 
-  let build t args =
+
+  let build ~ctxt t args =
     BaseCustom.hook
       t.package.build_custom
-      (t.build t.package)
+      (t.build ~ctxt t.package)
       args
 
-  let doc t args =
+
+  let doc ~ctxt t args =
     BaseDoc.doc
+      ~ctxt
       (join_plugin_sections
          (function
             | Doc (cs, e) ->
@@ -4017,8 +5555,10 @@
       t.package
       args
 
-  let test t args =
+
+  let test ~ctxt t args =
     BaseTest.test
+      ~ctxt
       (join_plugin_sections
          (function
             | Test (cs, e) ->
@@ -4036,13 +5576,11 @@
       t.package
       args
 
-  let all t args =
-    let rno_doc =
-      ref false
-    in
-    let rno_test =
-      ref false
-    in
+
+  let all ~ctxt t args =
+    let rno_doc = ref false in
+    let rno_test = ref false in
+    let arg_rest = ref [] in
       Arg.parse_argv
         ~current:(ref 0)
         (Array.of_list
@@ -4056,54 +5594,49 @@
           "-no-test",
           Arg.Set rno_test,
           s_ "Don't run test target";
+
+        "--",
+        Arg.Rest (fun arg -> arg_rest := arg :: !arg_rest),
+        s_ "All arguments for configure.";
         ]
         (failwithf (f_ "Don't know what to do with '%s'"))
         "";
 
       info "Running configure step";
-      configure t [||];
+    configure ~ctxt t (Array.of_list (List.rev !arg_rest));
 
       info "Running build step";
-      build     t [||];
+    build ~ctxt t [||];
 
       (* Load setup.log dynamic variables *)
-      BaseDynVar.init t.package;
+    BaseDynVar.init ~ctxt t.package;
 
-      if not !rno_doc then
-        begin
+    if not !rno_doc then begin
           info "Running doc step";
-          doc t [||];
-        end
-      else
-        begin
+      doc ~ctxt t [||]
+    end else begin
           info "Skipping doc step"
         end;
-
-      if not !rno_test then
-        begin
+    if not !rno_test then begin
           info "Running test step";
-          test t [||]
-        end
-      else
-        begin
+      test ~ctxt t [||]
+    end else begin
           info "Skipping test step"
         end
 
-  let install t args =
-    BaseCustom.hook
-      t.package.install_custom
-      (t.install t.package)
-      args
 
-  let uninstall t args =
-    BaseCustom.hook
-      t.package.uninstall_custom
-      (t.uninstall t.package)
-      args
+  let install ~ctxt t args =
+    BaseCustom.hook t.package.install_custom (t.install ~ctxt t.package) args
+
+
+  let uninstall ~ctxt t args =
+    BaseCustom.hook t.package.uninstall_custom (t.uninstall ~ctxt t.package) args
+
+
+  let reinstall ~ctxt t args =
+    uninstall ~ctxt t args;
+    install ~ctxt t args
 
-  let reinstall t args =
-    uninstall t args;
-    install t args
 
   let clean, distclean =
     let failsafe f a =
@@ -4117,7 +5650,7 @@
              | e -> Printexc.to_string e)
     in
 
-    let generic_clean t cstm mains docs tests args =
+    let generic_clean ~ctxt t cstm mains docs tests args =
       BaseCustom.hook
         ~failsafe:true
         cstm
@@ -4130,39 +5663,27 @@
                       try
                         List.assoc cs.cs_name tests
                       with Not_found ->
-                        fun _ _ _ -> ()
+                   fun ~ctxt:_ _ _ _ -> ()
                     in
-                      failsafe
-                        (f t.package (cs, test))
-                        args
+                 failsafe (f ~ctxt t.package (cs, test)) args
                 | Doc (cs, doc) ->
                     let f =
                       try
                         List.assoc cs.cs_name docs
                       with Not_found ->
-                        fun _ _ _ -> ()
+                   fun ~ctxt:_ _ _ _ -> ()
                     in
-                      failsafe
-                        (f t.package (cs, doc))
-                        args
-                | Library _
-                | Executable _
-                | Flag _
-                | SrcRepo _ ->
-                    ())
+                 failsafe (f ~ctxt t.package (cs, doc)) args
+               | Library _ | Object _ | Executable _ | Flag _ | SrcRepo _ -> ())
              t.package.sections;
            (* Clean whole package *)
-           List.iter
-             (fun f ->
-                failsafe
-                  (f t.package)
-                  args)
-             mains)
+           List.iter (fun f -> failsafe (f ~ctxt t.package) args) mains)
         ()
     in
 
-    let clean t args =
+    let clean ~ctxt t args =
       generic_clean
+        ~ctxt
         t
         t.package.clean_custom
         t.clean
@@ -4171,12 +5692,13 @@
         args
     in
 
-    let distclean t args =
+    let distclean ~ctxt t args =
       (* Call clean *)
-      clean t args;
+      clean ~ctxt t args;
 
       (* Call distclean code *)
       generic_clean
+        ~ctxt
         t
         t.package.distclean_custom
         t.distclean
@@ -4184,25 +5706,22 @@
         t.distclean_test
         args;
 
-      (* Remove generated file *)
+      (* Remove generated source files. *)
       List.iter
         (fun fn ->
-           if Sys.file_exists fn then
-             begin
-               info (f_ "Remove '%s'") fn;
-               Sys.remove fn
+           if ctxt.srcfs#file_exists fn then begin
+             info (f_ "Remove '%s'") (ctxt.srcfs#string_of_filename fn);
+             ctxt.srcfs#remove fn
              end)
-        (BaseEnv.default_filename
-         ::
-         BaseLog.default_filename
-         ::
-         (List.rev_map BaseFileAB.to_filename t.package.files_ab))
+        ([BaseEnv.default_filename; BaseLog.default_filename]
+         @ (List.rev_map BaseFileAB.to_filename t.package.files_ab))
     in
 
       clean, distclean
 
-  let version t _ =
-    print_endline t.oasis_version
+
+  let version ~ctxt:_ (t: t) _ = print_endline t.oasis_version
+
 
   let update_setup_ml, no_update_setup_ml_cli =
     let b = ref true in
@@ -4211,11 +5730,15 @@
        Arg.Clear b,
        s_ " Don't try to update setup.ml, even if _oasis has changed.")
 
+  (* TODO: srcfs *)
+  let default_oasis_fn = "_oasis"
+
+
   let update_setup_ml t =
     let oasis_fn =
       match t.oasis_fn with
         | Some fn -> fn
-        | None -> "_oasis"
+        | None -> default_oasis_fn
     in
     let oasis_exec =
       match t.oasis_exec with
@@ -4288,10 +5811,8 @@
                 OASISExec.run
                   ~ctxt:!BaseContext.default
                   ~f_exit_code:
-                  (function
-                     | 0 ->
-                         ()
-                     | n ->
+                  (fun n ->
+                     if n <> 0 then
                          failwithf
                            (f_ "Unable to update setup.ml using '%s', \
                                 please fix the problem and retry.")
@@ -4313,7 +5834,8 @@
         try
           match t.oasis_digest with
             | Some dgst ->
-              if Sys.file_exists oasis_fn && dgst <> Digest.file "_oasis" then
+              if Sys.file_exists oasis_fn &&
+                 dgst <> Digest.file default_oasis_fn then
                 begin
                   do_update ();
                   true
@@ -4333,25 +5855,19 @@
     else
       false
 
+
   let setup t =
-    let catch_exn =
-      ref true
-    in
-      try
+    let catch_exn = ref true in
         let act_ref =
-          ref (fun _ ->
+      ref (fun ~ctxt:_ _ ->
                  failwithf
                    (f_ "No action defined, run '%s %s -help'")
                    Sys.executable_name
                    Sys.argv.(0))
 
         in
-        let extra_args_ref =
-          ref []
-        in
-        let allow_empty_env_ref =
-          ref false
-        in
+    let extra_args_ref = ref [] in
+    let allow_empty_env_ref = ref false in
         let arg_handle ?(allow_empty_env=false) act =
           Arg.Tuple
             [
@@ -4363,7 +5878,8 @@
                    act_ref := act);
             ]
         in
-
+    try
+      let () =
           Arg.parse
             (Arg.align
                ([
@@ -4425,10 +5941,14 @@
                    [])
                @ (BaseContext.args ())))
             (failwithf (f_ "Don't know what to do with '%s'"))
-            (s_ "Setup and run build process current package\n");
+          (s_ "Setup and run build process current package\n")
+      in
+
+      (* Instantiate the context. *)
+      let ctxt = !BaseContext.default in
 
           (* Build initial environment *)
-          load ~allow_empty:!allow_empty_env_ref ();
+      load ~ctxt ~allow_empty:!allow_empty_env_ref ();
 
           (** Initialize flags *)
           List.iter
@@ -4452,10 +5972,8 @@
                                              choices)))
                      in
                        match hlp with
-                         | Some hlp ->
-                             apply ~short_desc:(fun () -> hlp) ()
-                         | None ->
-                             apply ()
+              | Some hlp -> apply ~short_desc:(fun () -> hlp) ()
+              | None -> apply ()
                    end
                | _ ->
                    ())
@@ -4463,23 +5981,159 @@
 
           BaseStandardVar.init t.package;
 
-          BaseDynVar.init t.package;
+      BaseDynVar.init ~ctxt t.package;
 
-          if t.setup_update && update_setup_ml t then
-            ()
-          else
-            !act_ref t (Array.of_list (List.rev !extra_args_ref))
+      if not (t.setup_update && update_setup_ml t) then
+        !act_ref ~ctxt t (Array.of_list (List.rev !extra_args_ref))
 
       with e when !catch_exn ->
         error "%s" (Printexc.to_string e);
         exit 1
 
+
+end
+
+module BaseCompat = struct
+(* # 22 "src/base/BaseCompat.ml" *)
+
+  (** Compatibility layer to provide a stable API inside setup.ml.
+      This layer allows OASIS to change in between minor versions
+      (e.g. 0.4.6 -> 0.4.7) but still provides a stable API inside setup.ml. This
+      enables to write functions that manipulate setup_t inside setup.ml. See
+      deps.ml for an example.
+
+      The module opened by default will depend on the version of the _oasis. E.g.
+      if we have "OASISFormat: 0.3", the module Compat_0_3 will be opened and
+      the function Compat_0_3 will be called. If setup.ml is generated with the
+      -nocompat, no module will be opened.
+
+      @author Sylvain Le Gall
+    *)
+
+  module Compat_0_4 =
+  struct
+    let rctxt = ref !BaseContext.default
+
+    module BaseSetup =
+    struct
+      module Original = BaseSetup
+
+      open OASISTypes
+
+      type std_args_fun = package -> string array -> unit
+      type ('a, 'b) section_args_fun =
+        name * (package -> (common_section * 'a) -> string array -> 'b)
+      type t =
+        {
+          configure:        std_args_fun;
+          build:            std_args_fun;
+          doc:              ((doc, unit)  section_args_fun) list;
+          test:             ((test, float) section_args_fun) list;
+          install:          std_args_fun;
+          uninstall:        std_args_fun;
+          clean:            std_args_fun list;
+          clean_doc:        (doc, unit) section_args_fun list;
+          clean_test:       (test, unit) section_args_fun list;
+          distclean:        std_args_fun list;
+          distclean_doc:    (doc, unit) section_args_fun list;
+          distclean_test:   (test, unit) section_args_fun list;
+          package:          package;
+          oasis_fn:         string option;
+          oasis_version:    string;
+          oasis_digest:     Digest.t option;
+          oasis_exec:       string option;
+          oasis_setup_args: string list;
+          setup_update:     bool;
+        }
+
+      let setup t =
+        let mk_std_args_fun f =
+          fun ~ctxt pkg args -> rctxt := ctxt; f pkg args
+        in
+        let mk_section_args_fun l =
+          List.map
+            (fun (nm, f) ->
+               nm,
+               (fun ~ctxt pkg sct args ->
+                  rctxt := ctxt;
+                  f pkg sct args))
+            l
+        in
+        let t' =
+          {
+            Original.
+            configure =        mk_std_args_fun t.configure;
+            build =            mk_std_args_fun t.build;
+            doc =              mk_section_args_fun t.doc;
+            test =             mk_section_args_fun t.test;
+            install =          mk_std_args_fun t.install;
+            uninstall =        mk_std_args_fun t.uninstall;
+            clean =            List.map mk_std_args_fun t.clean;
+            clean_doc =        mk_section_args_fun t.clean_doc;
+            clean_test =       mk_section_args_fun t.clean_test;
+            distclean =        List.map mk_std_args_fun t.distclean;
+            distclean_doc =    mk_section_args_fun t.distclean_doc;
+            distclean_test =   mk_section_args_fun t.distclean_test;
+
+            package =          t.package;
+            oasis_fn =         t.oasis_fn;
+            oasis_version =    t.oasis_version;
+            oasis_digest =     t.oasis_digest;
+            oasis_exec =       t.oasis_exec;
+            oasis_setup_args = t.oasis_setup_args;
+            setup_update =     t.setup_update;
+          }
+        in
+        Original.setup t'
+
+    end
+
+    let adapt_setup_t setup_t =
+      let module O = BaseSetup.Original in
+      let mk_std_args_fun f = fun pkg args -> f ~ctxt:!rctxt pkg args in
+      let mk_section_args_fun l =
+        List.map
+          (fun (nm, f) -> nm, (fun pkg sct args -> f ~ctxt:!rctxt pkg sct args))
+          l
+      in
+      {
+        BaseSetup.
+        configure =        mk_std_args_fun setup_t.O.configure;
+        build =            mk_std_args_fun setup_t.O.build;
+        doc =              mk_section_args_fun setup_t.O.doc;
+        test =             mk_section_args_fun setup_t.O.test;
+        install =          mk_std_args_fun setup_t.O.install;
+        uninstall =        mk_std_args_fun setup_t.O.uninstall;
+        clean =            List.map mk_std_args_fun setup_t.O.clean;
+        clean_doc =        mk_section_args_fun setup_t.O.clean_doc;
+        clean_test =       mk_section_args_fun setup_t.O.clean_test;
+        distclean =        List.map mk_std_args_fun setup_t.O.distclean;
+        distclean_doc =    mk_section_args_fun setup_t.O.distclean_doc;
+        distclean_test =   mk_section_args_fun setup_t.O.distclean_test;
+
+        package =          setup_t.O.package;
+        oasis_fn =         setup_t.O.oasis_fn;
+        oasis_version =    setup_t.O.oasis_version;
+        oasis_digest =     setup_t.O.oasis_digest;
+        oasis_exec =       setup_t.O.oasis_exec;
+        oasis_setup_args = setup_t.O.oasis_setup_args;
+        setup_update =     setup_t.O.setup_update;
+      }
+  end
+
+
+  module Compat_0_3 =
+  struct
+    include Compat_0_4
+  end
+
 end
 
 
-# 4480 "setup.ml"
+# 6133 "setup.ml"
 module InternalConfigurePlugin = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/plugins/internal/InternalConfigurePlugin.ml" *)
+(* # 22 "src/plugins/internal/InternalConfigurePlugin.ml" *)
+
 
   (** Configure using internal scheme
       @author Sylvain Le Gall
@@ -4491,24 +6146,14 @@
   open OASISGettext
   open BaseMessage
 
+
   (** Configure build using provided series of check to be done
-    * and then output corresponding file.
+      and then output corresponding file.
     *)
-  let configure pkg argv =
-    let var_ignore_eval var =
-      let _s : string =
-        var ()
-      in
-        ()
-    in
-
-    let errors =
-      ref SetString.empty
-    in
-
-    let buff =
-      Buffer.create 13
-    in
+  let configure ~ctxt:_ pkg argv =
+    let var_ignore_eval var = let _s: string = var () in () in
+    let errors = ref SetString.empty in
+    let buff = Buffer.create 13 in
 
     let add_errors fmt =
       Printf.kbprintf
@@ -4539,8 +6184,8 @@
                (* Check that matching tool is built *)
                List.iter
                  (function
-                    | Executable ({cs_name = nm2},
-                                  {bs_build = build},
+                | Executable ({cs_name = nm2; _},
+                              {bs_build = build; _},
                                   _) when nm1 = nm2 ->
                          if not (var_choose build) then
                            add_errors
@@ -4595,8 +6240,8 @@
                    (* Check that matching library is built *)
                    List.iter
                      (function
-                        | Library ({cs_name = nm2},
-                                   {bs_build = build},
+                    | Library ({cs_name = nm2; _},
+                               {bs_build = build; _},
                                    _) when nm1 = nm2 ->
                              if not (var_choose build) then
                                add_errors
@@ -4656,6 +6301,20 @@
         | None ->
             ()
     end;
+    (* Make sure the findlib version is fine for the OCaml compiler. *)
+    begin
+      let ocaml_ge4 =
+        OASISVersion.version_compare
+          (OASISVersion.version_of_string (BaseStandardVar.ocaml_version ()))
+          (OASISVersion.version_of_string "4.0.0") >= 0 in
+      if ocaml_ge4 then
+        let findlib_lt132 =
+          OASISVersion.version_compare
+            (OASISVersion.version_of_string (BaseStandardVar.findlib_version()))
+            (OASISVersion.version_of_string "1.3.2") < 0 in
+        if findlib_lt132 then
+          add_errors "OCaml >= 4.0.0 requires Findlib version >= 1.3.2"
+    end;
 
     (* FlexDLL *)
     if BaseStandardVar.os_type () = "Win32" ||
@@ -4685,7 +6344,7 @@
       pkg.sections;
 
     (* Check if we need native dynlink (presence of libraries that compile to
-     * native)
+       native)
      *)
     begin
       let has_cmxa =
@@ -4721,42 +6381,50 @@
 end
 
 module InternalInstallPlugin = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/plugins/internal/InternalInstallPlugin.ml" *)
+(* # 22 "src/plugins/internal/InternalInstallPlugin.ml" *)
+
 
   (** Install using internal scheme
       @author Sylvain Le Gall
     *)
 
+
+  (* TODO: rewrite this module with OASISFileSystem. *)
+
   open BaseEnv
   open BaseStandardVar
   open BaseMessage
   open OASISTypes
-  open OASISLibrary
+  open OASISFindlib
   open OASISGettext
   open OASISUtils
 
-  let exec_hook =
-    ref (fun (cs, bs, exec) -> cs, bs, exec)
-
-  let lib_hook =
-    ref (fun (cs, bs, lib) -> cs, bs, lib, [])
-
-  let doc_hook =
-    ref (fun (cs, doc) -> cs, doc)
 
-  let install_file_ev =
-    "install-file"
+  let exec_hook = ref (fun (cs, bs, exec) -> cs, bs, exec)
+  let lib_hook  = ref (fun (cs, bs, dn, lib) -> cs, bs, dn, lib, [])
+  let obj_hook  = ref (fun (cs, bs, dn, obj) -> cs, bs, dn, obj, [])
+  let doc_hook  = ref (fun (cs, doc) -> cs, doc)
+
+  let install_file_ev    = "install-file"
+  let install_dir_ev     = "install-dir"
+  let install_findlib_ev = "install-findlib"
 
-  let install_dir_ev =
-    "install-dir"
-
-  let install_findlib_ev =
-    "install-findlib"
-
-  let win32_max_command_line_length = 8000
 
   let split_install_command ocamlfind findlib_name meta files =
-    if Sys.os_type = "Win32" then
+    if Sys.os_type <> "Win32" then
+      ["install" :: findlib_name :: meta :: files]
+    else
+      let f s =
+        OASISHostPath.quote ( OASISHostPath.of_unix s )
+      in
+      let files = List.map f files in
+      let meta = f meta  in
+      let win32_max_command_line_length =
+        if OASISHostPath.use_bash () = false then
+          7900
+        else
+          30000
+      in
       (* Arguments for the first command: *)
       let first_args = ["install"; findlib_name; meta] in
       (* Arguments for remaining commands: *)
@@ -4804,21 +6472,24 @@
                       in
                         if not findlib_ge_132 then
                           failwithf
-                            (f_ "Installing the library %s require to use the flag \
-                                 '-add' of ocamlfind because the command line is too \
-                                  long. This flag is only available for findlib 1.3.2. \
-                                  Please upgrade findlib from %s to 1.3.2")
+                            (f_ "Installing the library %s require to use the \
+                                 flag '-add' of ocamlfind because the command \
+                                 line is too long. This flag is only available \
+                                 for findlib 1.3.2. Please upgrade findlib from \
+                                 %s to 1.3.2")
                             findlib_name (BaseStandardVar.findlib_version ())
                     in
                     let cmds = split other_args others in
                     cmd :: cmds
       in
+      if files = [] then
+        [ first_args ]
+      else
       (* The first command does not use -add: *)
       split first_args files
-    else
-      ["install" :: findlib_name :: meta :: files]
 
-  let install pkg argv =
+
+  let install =
 
     let in_destdir =
       try
@@ -4833,9 +6504,9 @@
         fun fn -> fn
     in
 
-    let install_file ?tgt_fn src_file envdir =
+    let install_file ~ctxt ?(prepend_destdir=true) ?tgt_fn src_file envdir =
       let tgt_dir =
-        in_destdir (envdir ())
+        if prepend_destdir then in_destdir (envdir ()) else envdir ()
       in
       let tgt_file =
         Filename.concat
@@ -4848,20 +6519,48 @@
       in
         (* Create target directory if needed *)
         OASISFileUtil.mkdir_parent
-          ~ctxt:!BaseContext.default
+          ~ctxt
           (fun dn ->
              info (f_ "Creating directory '%s'") dn;
-             BaseLog.register install_dir_ev dn)
-          tgt_dir;
+             BaseLog.register ~ctxt install_dir_ev dn)
+          (Filename.dirname tgt_file);
 
         (* Really install files *)
         info (f_ "Copying file '%s' to '%s'") src_file tgt_file;
-        OASISFileUtil.cp ~ctxt:!BaseContext.default src_file tgt_file;
-        BaseLog.register install_file_ev tgt_file
+        OASISFileUtil.cp ~ctxt src_file tgt_file;
+        BaseLog.register ~ctxt install_file_ev tgt_file
+    in
+
+    (* Install the files for a library. *)
+
+    let install_lib_files ~ctxt findlib_name files =
+      let findlib_dir =
+        let dn =
+          let findlib_destdir =
+            OASISExec.run_read_one_line ~ctxt (ocamlfind ())
+              ["printconf" ; "destdir"]
+          in
+          Filename.concat findlib_destdir findlib_name
+        in
+        fun () -> dn
+      in
+      let () =
+        if not (OASISFileUtil.file_exists_case (findlib_dir ())) then
+          failwithf
+            (f_ "Directory '%s' doesn't exist for findlib library %s")
+            (findlib_dir ()) findlib_name
+      in
+      let f dir file =
+        let basename = Filename.basename file in
+        let tgt_fn = Filename.concat dir basename in
+        (* Destdir is already include in printconf. *)
+        install_file ~ctxt ~prepend_destdir:false ~tgt_fn file findlib_dir
+      in
+      List.iter (fun (dir, files) -> List.iter (f dir) files) files ;
     in
 
     (* Install data into defined directory *)
-    let install_data srcdir lst tgtdir =
+    let install_data ~ctxt srcdir lst tgtdir =
       let tgtdir =
         OASISHostPath.of_unix (var_expand tgtdir)
       in
@@ -4878,7 +6577,7 @@
                    src;
                List.iter
                  (fun fn ->
-                    install_file
+                    install_file ~ctxt
                       fn
                       (fun () ->
                          match tgt_opt with
@@ -4890,63 +6589,109 @@
           lst
     in
 
+    let make_fnames modul sufx =
+      List.fold_right
+        begin fun sufx accu ->
+          (OASISString.capitalize_ascii modul ^ sufx) ::
+          (OASISString.uncapitalize_ascii modul ^ sufx) ::
+          accu
+        end
+        sufx
+        []
+    in
+
     (** Install all libraries *)
-    let install_libs pkg =
+    let install_libs ~ctxt pkg =
 
-      let files_of_library (f_data, acc) data_lib =
-        let cs, bs, lib, lib_extra =
-          !lib_hook data_lib
-        in
-          if var_choose bs.bs_install &&
-             BaseBuilt.is_built BaseBuilt.BLib cs.cs_name then
-            begin
-              let acc =
-                (* Start with acc + lib_extra *)
-                List.rev_append lib_extra acc
-              in
-              let acc =
-                (* Add uncompiled header from the source tree *)
-                let path =
-                  OASISHostPath.of_unix bs.bs_path
+      let find_first_existing_files_in_path bs lst =
+        let path = OASISHostPath.of_unix bs.bs_path in
+        List.find
+          OASISFileUtil.file_exists_case
+          (List.map (Filename.concat path) lst)
                 in
+
+      let files_of_modules new_files typ cs bs modules =
                   List.fold_left
                     (fun acc modul ->
+             begin
                        try
-                         List.find
-                           OASISFileUtil.file_exists_case
-                           (List.map
-                              (Filename.concat path)
-                              [modul^".mli";
-                               modul^".ml";
-                               String.uncapitalize modul^".mli";
-                               String.capitalize   modul^".mli";
-                               String.uncapitalize modul^".ml";
-                               String.capitalize   modul^".ml"])
-                         :: acc
+                 (* Add uncompiled header from the source tree *)
+                 [find_first_existing_files_in_path
+                    bs (make_fnames modul [".mli"; ".ml"])]
                        with Not_found ->
-                         begin
                            warning
                              (f_ "Cannot find source header for module %s \
-                                  in library %s")
-                             modul cs.cs_name;
-                           acc
-                         end)
-                    acc
-                    lib.lib_modules
+                        in %s %s")
+                   typ modul cs.cs_name;
+                 []
+             end
+             @
+             List.fold_left
+               (fun acc fn ->
+                  try
+                    find_first_existing_files_in_path bs [fn] :: acc
+                  with Not_found ->
+                    acc)
+               acc (make_fnames modul [".annot";".cmti";".cmt"]))
+          new_files
+          modules
               in
 
-              let acc =
+      let files_of_build_section (f_data, new_files) typ cs bs =
+        let extra_files =
+          List.map
+            (fun fn ->
+               try
+                 find_first_existing_files_in_path bs [fn]
+               with Not_found ->
+                 failwithf
+                   (f_ "Cannot find extra findlib file %S in %s %s ")
+                   fn
+                   typ
+                   cs.cs_name)
+            bs.bs_findlib_extra_files
+        in
+        let f_data () =
+          (* Install data associated with the library *)
+          install_data
+            ~ctxt
+            bs.bs_path
+            bs.bs_data_files
+            (Filename.concat
+               (datarootdir ())
+               pkg.name);
+          f_data ()
+        in
+        f_data, new_files @ extra_files
+      in
+
+      let files_of_library (f_data, acc) data_lib =
+        let cs, bs, lib, dn, lib_extra = !lib_hook data_lib in
+        if var_choose bs.bs_install &&
+           BaseBuilt.is_built ~ctxt BaseBuilt.BLib cs.cs_name then begin
+          (* Start with lib_extra *)
+          let new_files = lib_extra in
+          let new_files =
+            files_of_modules new_files "library" cs bs lib.lib_modules
+          in
+          let f_data, new_files =
+            files_of_build_section (f_data, new_files) "library" cs bs
+          in
+          let new_files =
                (* Get generated files *)
                BaseBuilt.fold
+              ~ctxt
                  BaseBuilt.BLib
                  cs.cs_name
                  (fun acc fn -> fn :: acc)
-                 acc
+              new_files
               in
+          let acc = (dn, new_files) :: acc in
 
               let f_data () =
                 (* Install data associated with the library *)
                 install_data
+              ~ctxt
                   bs.bs_path
                   bs.bs_data_files
                   (Filename.concat
@@ -4956,9 +6701,44 @@
               in
 
                 (f_data, acc)
+        end else begin
+          (f_data, acc)
             end
-           else
-            begin
+      and files_of_object (f_data, acc) data_obj =
+        let cs, bs, obj, dn, obj_extra = !obj_hook data_obj in
+        if var_choose bs.bs_install &&
+           BaseBuilt.is_built ~ctxt BaseBuilt.BObj cs.cs_name then begin
+          (* Start with obj_extra *)
+          let new_files = obj_extra in
+          let new_files =
+            files_of_modules new_files "object" cs bs obj.obj_modules
+          in
+          let f_data, new_files =
+            files_of_build_section (f_data, new_files) "object" cs bs
+          in
+
+          let new_files =
+            (* Get generated files *)
+            BaseBuilt.fold
+              ~ctxt
+              BaseBuilt.BObj
+              cs.cs_name
+              (fun acc fn -> fn :: acc)
+              new_files
+          in
+          let acc = (dn, new_files) :: acc in
+
+          let f_data () =
+            (* Install data associated with the object *)
+            install_data
+              ~ctxt
+              bs.bs_path
+              bs.bs_data_files
+              (Filename.concat (datarootdir ()) pkg.name);
+            f_data ()
+          in
+          (f_data, acc)
+        end else begin
               (f_data, acc)
             end
       in
@@ -4971,8 +6751,10 @@
             match grp with
               | Container (_, children) ->
                   data_and_files, children
-              | Package (_, cs, bs, lib, children) ->
-                  files_of_library data_and_files (cs, bs, lib), children
+              | Package (_, cs, bs, `Library lib, dn, children) ->
+                  files_of_library data_and_files (cs, bs, lib, dn), children
+              | Package (_, cs, bs, `Object obj, dn, children) ->
+                  files_of_object data_and_files (cs, bs, obj, dn), children
           in
             List.fold_left
               install_group_lib_aux
@@ -4981,37 +6763,23 @@
         in
 
         (* Findlib name of the root library *)
-        let findlib_name =
-          findlib_of_group grp
-        in
+        let findlib_name = findlib_of_group grp in
 
         (* Determine root library *)
-        let root_lib =
-          root_of_group grp
-        in
+        let root_lib = root_of_group grp in
 
         (* All files to install for this library *)
-        let f_data, files =
-          install_group_lib_aux (ignore, []) grp
-        in
+        let f_data, files = install_group_lib_aux (ignore, []) grp in
 
           (* Really install, if there is something to install *)
-          if files = [] then
-            begin
+        if files = [] then begin
               warning
-                (f_ "Nothing to install for findlib library '%s'")
-                findlib_name
-            end
-          else
-            begin
+            (f_ "Nothing to install for findlib library '%s'") findlib_name
+        end else begin
               let meta =
                 (* Search META file *)
-                let (_, bs, _) =
-                  root_lib
-                in
-                let res =
-                  Filename.concat bs.bs_path "META"
-                in
+            let _, bs, _ = root_lib in
+            let res = Filename.concat bs.bs_path "META" in
                   if not (OASISFileUtil.file_exists_case res) then
                     failwithf
                       (f_ "Cannot find file '%s' for findlib library %s")
@@ -5023,45 +6791,42 @@
                 (* Make filename shorter to avoid hitting command max line length
                  * too early, esp. on Windows.
                  *)
+            (* TODO: move to OASISHostPath as make_relative. *)
                 let remove_prefix p n =
                   let plen = String.length p in
                   let nlen = String.length n in
-                    if plen <= nlen && String.sub n 0 plen = p then
-                      begin
-                        let fn_sep = 
-                          if Sys.os_type = "Win32" then
-                            '\\'
-                          else
-                            '/'
-                        in
-                        let cutpoint = plen +
-                          (if plen < nlen && n.[plen] = fn_sep then 
-                             1
-                           else 
-                             0)
+              if plen <= nlen && String.sub n 0 plen = p then begin
+                let fn_sep = if Sys.os_type = "Win32" then '\\' else '/' in
+                let cutpoint =
+                  plen +
+                  (if plen < nlen && n.[plen] = fn_sep then 1 else 0)
                         in
                           String.sub n cutpoint (nlen - cutpoint)
-                      end
-                    else 
+              end else begin
                       n
+              end
                 in
-                  List.map (remove_prefix (Sys.getcwd ())) files 
+            List.map
+              (fun (dir, fn) ->
+                 (dir, List.map (remove_prefix (Sys.getcwd ())) fn))
+              files
               in
-                info
-                  (f_ "Installing findlib library '%s'")
-                  findlib_name;
                 let ocamlfind = ocamlfind () in
-                let commands =
-                  split_install_command
-                    ocamlfind
-                    findlib_name
-                    meta
-                    files
+          let nodir_files, dir_files =
+            List.fold_left
+              (fun (nodir, dir) (dn, lst) ->
+                 match dn with
+                 | Some dn -> nodir, (dn, lst) :: dir
+                 | None -> lst @ nodir, dir)
+              ([], [])
+              (List.rev files)
                 in
+          info (f_ "Installing findlib library '%s'") findlib_name;
                 List.iter
-                  (OASISExec.run ~ctxt:!BaseContext.default ocamlfind)
-                  commands;
-                BaseLog.register install_findlib_ev findlib_name
+            (OASISExec.run ~ctxt ocamlfind)
+            (split_install_command ocamlfind findlib_name meta nodir_files);
+          install_lib_files ~ctxt findlib_name dir_files;
+          BaseLog.register ~ctxt install_findlib_ev findlib_name
             end;
 
           (* Install data files *)
@@ -5066,84 +6831,62 @@
 
           (* Install data files *)
           f_data ();
-
       in
 
-      let group_libs, _, _ =
-        findlib_mapping pkg
-      in
+      let group_libs, _, _ = findlib_mapping pkg in
 
         (* We install libraries in groups *)
         List.iter install_group_lib group_libs
     in
 
-    let install_execs pkg =
+    let install_execs ~ctxt pkg =
       let install_exec data_exec =
-        let (cs, bs, exec) =
-          !exec_hook data_exec
-        in
+        let cs, bs, _ = !exec_hook data_exec in
           if var_choose bs.bs_install &&
-             BaseBuilt.is_built BaseBuilt.BExec cs.cs_name then
-            begin
-              let exec_libdir () =
-                Filename.concat
-                  (libdir ())
-                  pkg.name
-              in
+           BaseBuilt.is_built ~ctxt BaseBuilt.BExec cs.cs_name then begin
+          let exec_libdir () = Filename.concat (libdir ()) pkg.name in
                 BaseBuilt.fold
+            ~ctxt
                   BaseBuilt.BExec
                   cs.cs_name
                   (fun () fn ->
-                     install_file
+               install_file ~ctxt
                        ~tgt_fn:(cs.cs_name ^ ext_program ())
                        fn
                        bindir)
                   ();
                 BaseBuilt.fold
+            ~ctxt
                   BaseBuilt.BExecLib
                   cs.cs_name
-                  (fun () fn ->
-                     install_file
-                       fn
-                       exec_libdir)
+            (fun () fn -> install_file ~ctxt fn exec_libdir)
                   ();
-                install_data
+          install_data ~ctxt
                   bs.bs_path
                   bs.bs_data_files
-                  (Filename.concat
-                     (datarootdir ())
-                     pkg.name)
+            (Filename.concat (datarootdir ()) pkg.name)
             end
       in
         List.iter
           (function
-             | Executable (cs, bs, exec)->
-                 install_exec (cs, bs, exec)
-             | _ ->
-                 ())
+          | Executable (cs, bs, exec)-> install_exec (cs, bs, exec)
+          | _ -> ())
           pkg.sections
     in
 
-    let install_docs pkg =
+    let install_docs ~ctxt pkg =
       let install_doc data =
-        let (cs, doc) =
-          !doc_hook data
-        in
+        let cs, doc = !doc_hook data in
           if var_choose doc.doc_install &&
-             BaseBuilt.is_built BaseBuilt.BDoc cs.cs_name then
-            begin
-              let tgt_dir =
-                OASISHostPath.of_unix (var_expand doc.doc_install_dir)
-              in
+           BaseBuilt.is_built ~ctxt BaseBuilt.BDoc cs.cs_name then begin
+          let tgt_dir = OASISHostPath.of_unix (var_expand doc.doc_install_dir) in
                 BaseBuilt.fold
+            ~ctxt
                   BaseBuilt.BDoc
                   cs.cs_name
-                  (fun () fn ->
-                     install_file
-                       fn
-                       (fun () -> tgt_dir))
+            (fun () fn -> install_file ~ctxt fn (fun () -> tgt_dir))
                 ();
-                install_data
+          install_data ~ctxt
                   Filename.current_dir_name
                   doc.doc_data_files
                   doc.doc_install_dir
@@ -5151,88 +6894,62 @@
       in
         List.iter
           (function
-             | Doc (cs, doc) ->
-                 install_doc (cs, doc)
-             | _ ->
-                 ())
+          | Doc (cs, doc) -> install_doc (cs, doc)
+          | _ -> ())
           pkg.sections
     in
+    fun ~ctxt pkg _ ->
+      install_libs ~ctxt pkg;
+      install_execs ~ctxt pkg;
+      install_docs ~ctxt pkg
 
-      install_libs  pkg;
-      install_execs pkg;
-      install_docs  pkg
 
   (* Uninstall already installed data *)
-  let uninstall _ argv =
-    List.iter
-      (fun (ev, data) ->
-         if ev = install_file_ev then
-           begin
-             if OASISFileUtil.file_exists_case data then
-               begin
-                 info
-                   (f_ "Removing file '%s'")
-                   data;
+  let uninstall ~ctxt _ _ =
+    let uninstall_aux (ev, data) =
+      if ev = install_file_ev then begin
+        if OASISFileUtil.file_exists_case data then begin
+          info (f_ "Removing file '%s'") data;
                  Sys.remove data
+        end else begin
+          warning (f_ "File '%s' doesn't exist anymore") data
                end
-             else
-               begin
-                 warning
-                   (f_ "File '%s' doesn't exist anymore")
-                   data
-               end
-           end
-         else if ev = install_dir_ev then
-           begin
-             if Sys.file_exists data && Sys.is_directory data then
-               begin
-                 if Sys.readdir data = [||] then
-                   begin
-                     info
-                       (f_ "Removing directory '%s'")
-                       data;
-                     OASISFileUtil.rmdir ~ctxt:!BaseContext.default data
-                   end
-                 else
-                   begin
+      end else if ev = install_dir_ev then begin
+        if Sys.file_exists data && Sys.is_directory data then begin
+          if Sys.readdir data = [||] then begin
+            info (f_ "Removing directory '%s'") data;
+            OASISFileUtil.rmdir ~ctxt data
+          end else begin
                      warning
                        (f_ "Directory '%s' is not empty (%s)")
                        data
-                       (String.concat
-                          ", "
-                          (Array.to_list
-                             (Sys.readdir data)))
+              (String.concat ", " (Array.to_list (Sys.readdir data)))
                    end
+        end else begin
+          warning (f_ "Directory '%s' doesn't exist anymore") data
                end
-             else
-               begin
-                 warning
-                   (f_ "Directory '%s' doesn't exist anymore")
-                   data
-               end
-           end
-         else if ev = install_findlib_ev then
-           begin
+      end else if ev = install_findlib_ev then begin
              info (f_ "Removing findlib library '%s'") data;
-             OASISExec.run ~ctxt:!BaseContext.default
-               (ocamlfind ()) ["remove"; data]
-           end
-         else
+        OASISExec.run ~ctxt (ocamlfind ()) ["remove"; data]
+      end else begin
            failwithf (f_ "Unknown log event '%s'") ev;
-         BaseLog.unregister ev data)
+      end;
+      BaseLog.unregister ~ctxt ev data
+    in
       (* We process event in reverse order *)
+    List.iter uninstall_aux
       (List.rev
-         (BaseLog.filter
-            [install_file_ev;
-             install_dir_ev;
-             install_findlib_ev;]))
+         (BaseLog.filter ~ctxt [install_file_ev; install_dir_ev]));
+    List.iter uninstall_aux
+      (List.rev (BaseLog.filter ~ctxt [install_findlib_ev]))
 
 end
 
 
-# 5233 "setup.ml"
+# 6949 "setup.ml"
 module OCamlbuildCommon = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/plugins/ocamlbuild/OCamlbuildCommon.ml" *)
+(* # 22 "src/plugins/ocamlbuild/OCamlbuildCommon.ml" *)
+
 
   (** Functions common to OCamlbuild build and doc plugin
     *)
@@ -5240,9 +6958,14 @@
   open OASISGettext
   open BaseEnv
   open BaseStandardVar
+  open OASISTypes
+
+
+  type extra_args = string list
+
+
+  let ocamlbuild_clean_ev = "ocamlbuild-clean"
 
-  let ocamlbuild_clean_ev =
-    "ocamlbuild-clean"
 
   let ocamlbuildflags =
     var_define
@@ -5259,6 +6983,14 @@
             "-classic-display";
             "-no-log";
             "-no-links";
+          ]
+        else
+          [];
+
+        if OASISVersion.comparator_apply
+            (OASISVersion.version_of_string (ocaml_version ()))
+            (OASISVersion.VLesser (OASISVersion.version_of_string "3.11.1")) then
+          [
             "-install-lib-dir";
             (Filename.concat (standard_library ()) "ocamlbuild")
           ]
@@ -5278,6 +7010,11 @@
         else
           [];
 
+        if bool_of_string (tests ()) then
+          ["-tag"; "tests"]
+        else
+          [];
+
         if bool_of_string (profile ()) then
           ["-tag"; "profile"]
         else
@@ -5288,35 +7025,35 @@
         Array.to_list extra_argv;
       ]
 
+
   (** Run 'ocamlbuild -clean' if not already done *)
-  let run_clean extra_argv =
+  let run_clean ~ctxt extra_argv =
     let extra_cli =
       String.concat " " (Array.to_list extra_argv)
     in
       (* Run if never called with these args *)
-      if not (BaseLog.exists ocamlbuild_clean_ev extra_cli) then
+    if not (BaseLog.exists ~ctxt ocamlbuild_clean_ev extra_cli) then
         begin
-          OASISExec.run ~ctxt:!BaseContext.default
-            (ocamlbuild ()) (fix_args ["-clean"] extra_argv);
-          BaseLog.register ocamlbuild_clean_ev extra_cli;
+        OASISExec.run ~ctxt (ocamlbuild ()) (fix_args ["-clean"] extra_argv);
+        BaseLog.register ~ctxt ocamlbuild_clean_ev extra_cli;
           at_exit
             (fun () ->
                try
-                 BaseLog.unregister ocamlbuild_clean_ev extra_cli
-               with _ ->
-                 ())
+               BaseLog.unregister ~ctxt ocamlbuild_clean_ev extra_cli
+             with _ -> ())
         end
 
+
   (** Run ocamlbuild, unregister all clean events *)
-  let run_ocamlbuild args extra_argv =
+  let run_ocamlbuild ~ctxt args extra_argv =
     (* TODO: enforce that target in args must be UNIX encoded i.e. toto/index.html
      *)
-    OASISExec.run ~ctxt:!BaseContext.default
-      (ocamlbuild ()) (fix_args args extra_argv);
+    OASISExec.run ~ctxt (ocamlbuild ()) (fix_args args extra_argv);
     (* Remove any clean event, we must run it again *)
     List.iter
-      (fun (e, d) -> BaseLog.unregister e d)
-      (BaseLog.filter [ocamlbuild_clean_ev])
+      (fun (e, d) -> BaseLog.unregister ~ctxt e d)
+      (BaseLog.filter ~ctxt [ocamlbuild_clean_ev])
+
 
   (** Determine real build directory *)
   let build_dir extra_argv =
@@ -5334,7 +7072,8 @@
 end
 
 module OCamlbuildPlugin = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/plugins/ocamlbuild/OCamlbuildPlugin.ml" *)
+(* # 22 "src/plugins/ocamlbuild/OCamlbuildPlugin.ml" *)
+
 
   (** Build using ocamlbuild
       @author Sylvain Le Gall
@@ -5343,16 +7083,16 @@
   open OASISTypes
   open OASISGettext
   open OASISUtils
+  open OASISString
   open BaseEnv
   open OCamlbuildCommon
   open BaseStandardVar
-  open BaseMessage
 
-  let cond_targets_hook =
-    ref (fun lst -> lst)
 
-  let build pkg argv =
+  let cond_targets_hook = ref (fun lst -> lst)
 
+
+  let build ~ctxt extra_args pkg argv =
     (* Return the filename in build directory *)
     let in_build_dir fn =
       Filename.concat
@@ -5372,21 +7112,41 @@
              | Library (cs, bs, lib) when var_choose bs.bs_build ->
                  begin
                    let evs, unix_files =
-                     BaseBuilt.of_library
+                     BaseBuilt.of_library
+                       in_build_dir_of_unix
+                       (cs, bs, lib)
+                   in
+
+                   let tgts =
+                     List.flatten
+                       (List.filter
+                          (fun l -> l <> [])
+                          (List.map
+                             (List.filter
+                                (fun fn ->
+                                 ends_with ~what:".cma" fn
+                                 || ends_with ~what:".cmxs" fn
+                                 || ends_with ~what:".cmxa" fn
+                                 || ends_with ~what:(ext_lib ()) fn
+                                 || ends_with ~what:(ext_dll ()) fn))
+                             unix_files))
+                   in
+
+                     match tgts with
+                       | _ :: _ ->
+                           (evs, tgts) :: acc
+                       | [] ->
+                           failwithf
+                             (f_ "No possible ocamlbuild targets for library %s")
+                             cs.cs_name
+                 end
+
+             | Object (cs, bs, obj) when var_choose bs.bs_build ->
+                 begin
+                   let evs, unix_files =
+                     BaseBuilt.of_object
                        in_build_dir_of_unix
-                       (cs, bs, lib)
-                   in
-
-                   let ends_with nd fn =
-                     let nd_len =
-                       String.length nd
-                     in
-                       (String.length fn >= nd_len)
-                       &&
-                       (String.sub
-                          fn
-                          (String.length fn - nd_len)
-                          nd_len) = nd
+                       (cs, bs, obj)
                    in
 
                    let tgts =
@@ -5396,11 +7156,8 @@
                           (List.map
                              (List.filter
                                 (fun fn ->
-                                 ends_with ".cma" fn
-                                 || ends_with ".cmxs" fn
-                                 || ends_with ".cmxa" fn
-                                 || ends_with (ext_lib ()) fn
-                                 || ends_with (ext_dll ()) fn))
+                                 ends_with ~what:".cmo" fn
+                                 || ends_with ~what:".cmx" fn))
                              unix_files))
                    in
 
@@ -5409,16 +7166,14 @@
                            (evs, tgts) :: acc
                        | [] ->
                            failwithf
-                             (f_ "No possible ocamlbuild targets for library %s")
+                             (f_ "No possible ocamlbuild targets for object %s")
                              cs.cs_name
                  end
 
              | Executable (cs, bs, exec) when var_choose bs.bs_build ->
                  begin
-                   let evs, unix_exec_is, unix_dll_opt =
-                     BaseBuilt.of_executable
-                       in_build_dir_of_unix
-                       (cs, bs, exec)
+                   let evs, _, _ =
+                     BaseBuilt.of_executable in_build_dir_of_unix (cs, bs, exec)
                    in
 
                    let target ext =
@@ -5432,8 +7187,9 @@
                        (* Fix evs, we want to use the unix_tgt, without copying *)
                        List.map
                          (function
-                            | BaseBuilt.BExec, nm, lst when nm = cs.cs_name ->
-                                BaseBuilt.BExec, nm, [[in_build_dir_of_unix unix_tgt]]
+                            | BaseBuilt.BExec, nm, _ when nm = cs.cs_name ->
+                                BaseBuilt.BExec, nm,
+                                [[in_build_dir_of_unix unix_tgt]]
                             | ev ->
                                 ev)
                          evs
@@ -5455,7 +7211,7 @@
                      acc
                  end
 
-             | Library _ | Executable _ | Test _
+             | Library _ | Object _ | Executable _ | Test _
              | SrcRepo _ | Flag _ | Doc _ ->
                  acc)
         []
@@ -5469,37 +7225,36 @@
         (fun fns ->
            if not (List.exists OASISFileUtil.file_exists_case fns) then
              failwithf
-               (f_ "No one of expected built files %s exists")
-               (String.concat (s_ ", ") (List.map (Printf.sprintf "'%s'") fns)))
+               (fn_
+                  "Expected built file %s doesn't exist."
+                  "None of expected built files %s exists."
+                  (List.length fns))
+               (String.concat (s_ " or ") (List.map (Printf.sprintf "'%s'") fns)))
         lst;
-        (BaseBuilt.register bt bnm lst)
+        (BaseBuilt.register ~ctxt bt bnm lst)
     in
 
-    let cond_targets =
       (* Run the hook *)
-      !cond_targets_hook cond_targets
-    in
+    let cond_targets = !cond_targets_hook cond_targets in
 
       (* Run a list of target... *)
       run_ocamlbuild 
-        (List.flatten 
-           (List.map snd cond_targets))
+      ~ctxt
+      (List.flatten (List.map snd cond_targets) @ extra_args)
         argv;
       (* ... and register events *)
-      List.iter
-        check_and_register
-        (List.flatten (List.map fst cond_targets))
+    List.iter check_and_register (List.flatten (List.map fst cond_targets))
 
 
-  let clean pkg extra_args  =
-    run_clean extra_args;
+  let clean ~ctxt pkg extra_args  =
+    run_clean ~ctxt extra_args;
     List.iter
       (function
          | Library (cs, _, _) ->
-             BaseBuilt.unregister BaseBuilt.BLib cs.cs_name
+             BaseBuilt.unregister ~ctxt BaseBuilt.BLib cs.cs_name
          | Executable (cs, _, _) ->
-             BaseBuilt.unregister BaseBuilt.BExec cs.cs_name;
-             BaseBuilt.unregister BaseBuilt.BExecLib cs.cs_name
+             BaseBuilt.unregister ~ctxt BaseBuilt.BExec cs.cs_name;
+             BaseBuilt.unregister ~ctxt BaseBuilt.BExecLib cs.cs_name
          | _ ->
              ())
       pkg.sections
@@ -5507,7 +7263,8 @@
 end
 
 module OCamlbuildDocPlugin = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/plugins/ocamlbuild/OCamlbuildDocPlugin.ml" *)
+(* # 22 "src/plugins/ocamlbuild/OCamlbuildDocPlugin.ml" *)
+
 
   (* Create documentation using ocamlbuild .odocl files
      @author Sylvain Le Gall
@@ -5513,19 +7270,24 @@
      @author Sylvain Le Gall
    *)
 
+
   open OASISTypes
   open OASISGettext
-  open OASISMessage
   open OCamlbuildCommon
-  open BaseStandardVar
 
 
+  type run_t =
+    {
+      extra_args: string list;
+      run_path: unix_filename;
+    }
+
 
-  let doc_build path pkg (cs, doc) argv =
+  let doc_build ~ctxt run _ (cs, _) argv =
     let index_html =
       OASISUnixPath.make
         [
-          path;
+          run.run_path;
           cs.cs_name^".docdir";
           "index.html";
         ]
@@ -5534,30 +7296,33 @@
       OASISHostPath.make
         [
           build_dir argv;
-          OASISHostPath.of_unix path;
+          OASISHostPath.of_unix run.run_path;
           cs.cs_name^".docdir";
         ]
     in
-      run_ocamlbuild [index_html] argv;
+    run_ocamlbuild ~ctxt (index_html :: run.extra_args) argv;
       List.iter
         (fun glb ->
            BaseBuilt.register
+           ~ctxt
              BaseBuilt.BDoc
              cs.cs_name
-             [OASISFileUtil.glob ~ctxt:!BaseContext.default
-                (Filename.concat tgt_dir glb)])
+           [OASISFileUtil.glob ~ctxt (Filename.concat tgt_dir glb)])
         ["*.html"; "*.css"]
 
-  let doc_clean t pkg (cs, doc) argv =
-    run_clean argv;
-    BaseBuilt.unregister BaseBuilt.BDoc cs.cs_name
+
+  let doc_clean ~ctxt _ _ (cs, _) argv =
+    run_clean ~ctxt argv;
+    BaseBuilt.unregister ~ctxt BaseBuilt.BDoc cs.cs_name
+
 
 end
 
 
-# 5558 "setup.ml"
+# 7322 "setup.ml"
 module CustomPlugin = struct
-(* # 21 "/home/mzp/.opam/system/build/oasis.0.3.0/src/plugins/custom/CustomPlugin.ml" *)
+(* # 22 "src/plugins/custom/CustomPlugin.ml" *)
+
 
   (** Generate custom configure/build/doc/test/install system
       @author
@@ -5576,34 +7340,31 @@
         cmd_distclean: (command_line option) conditional;
       } 
 
+
   let run  = BaseCustom.run 
 
-  let main t _ extra_args =
-    let cmd, args =
-      var_choose 
-        ~name:(s_ "main command") 
-        t.cmd_main
-    in
+
+  let main ~ctxt:_ t _ extra_args =
+    let cmd, args = var_choose ~name:(s_ "main command") t.cmd_main in
       run cmd args extra_args 
 
-  let clean t pkg extra_args =
+
+  let clean ~ctxt:_ t _ extra_args =
     match var_choose t.cmd_clean with
-      | Some (cmd, args) ->
-          run cmd args extra_args
-      | _ ->
-          ()
+    | Some (cmd, args) -> run cmd args extra_args
+    | _ -> ()
 
-  let distclean t pkg extra_args =
+
+  let distclean ~ctxt:_ t _ extra_args =
     match var_choose t.cmd_distclean with
-      | Some (cmd, args) ->
-          run cmd args extra_args
-      | _ ->
-          ()
+    | Some (cmd, args) -> run cmd args extra_args
+    | _ -> ()
+
 
   module Build =
   struct 
-    let main t pkg extra_args =
-      main t pkg extra_args;
+    let main ~ctxt t pkg extra_args =
+      main ~ctxt t pkg extra_args;
       List.iter
         (fun sct ->
            let evs =
@@ -5630,35 +7391,35 @@
                    []
            in
              List.iter
-               (fun (bt, bnm, lst) -> BaseBuilt.register bt bnm lst)
+             (fun (bt, bnm, lst) -> BaseBuilt.register ~ctxt bt bnm lst)
                evs)
         pkg.sections
 
-    let clean t pkg extra_args =
-      clean t pkg extra_args;
+    let clean ~ctxt t pkg extra_args =
+      clean ~ctxt t pkg extra_args;
       (* TODO: this seems to be pretty generic (at least wrt to ocamlbuild
        * considering moving this to BaseSetup?
        *)
       List.iter
         (function
            | Library (cs, _, _) ->
-               BaseBuilt.unregister BaseBuilt.BLib cs.cs_name
+            BaseBuilt.unregister ~ctxt BaseBuilt.BLib cs.cs_name
            | Executable (cs, _, _) ->
-               BaseBuilt.unregister BaseBuilt.BExec cs.cs_name;
-               BaseBuilt.unregister BaseBuilt.BExecLib cs.cs_name
+            BaseBuilt.unregister ~ctxt BaseBuilt.BExec cs.cs_name;
+            BaseBuilt.unregister ~ctxt BaseBuilt.BExecLib cs.cs_name
            | _ ->
                ())
         pkg.sections
 
-    let distclean t pkg extra_args =
-      distclean t pkg extra_args
+    let distclean ~ctxt t pkg extra_args = distclean ~ctxt t pkg extra_args
   end
 
+
   module Test =
   struct
-    let main t pkg (cs, test) extra_args =
+    let main ~ctxt t pkg (cs, _) extra_args =
       try
-        main t pkg extra_args;
+        main ~ctxt t pkg extra_args;
         0.0
       with Failure s ->
         BaseMessage.warning 
@@ -5667,27 +7428,26 @@
           s;
         1.0
 
-    let clean t pkg (cs, test) extra_args =
-      clean t pkg extra_args
+    let clean ~ctxt t pkg _ extra_args = clean ~ctxt t pkg extra_args
 
-    let distclean t pkg (cs, test) extra_args =
-      distclean t pkg extra_args 
+    let distclean ~ctxt t pkg _ extra_args = distclean ~ctxt t pkg extra_args
   end
 
+
   module Doc =
   struct
-    let main t pkg (cs, _) extra_args =
-      main t pkg extra_args;
-      BaseBuilt.register BaseBuilt.BDoc cs.cs_name []
+    let main ~ctxt t pkg (cs, _) extra_args =
+      main ~ctxt t pkg extra_args;
+      BaseBuilt.register ~ctxt BaseBuilt.BDoc cs.cs_name []
 
-    let clean t pkg (cs, _) extra_args =
-      clean t pkg extra_args;
-      BaseBuilt.unregister BaseBuilt.BDoc cs.cs_name
+    let clean ~ctxt t pkg (cs, _) extra_args =
+      clean ~ctxt t pkg extra_args;
+      BaseBuilt.unregister ~ctxt BaseBuilt.BDoc cs.cs_name
 
-    let distclean t pkg (cs, _) extra_args =
-      distclean t pkg extra_args
+    let distclean ~ctxt t pkg _ extra_args = distclean ~ctxt t pkg extra_args
   end
 
+
 end
 
 
@@ -5691,13 +7451,13 @@
 end
 
 
-# 5694 "setup.ml"
+# 7454 "setup.ml"
 open OASISTypes;;
 
 let setup_t =
   {
      BaseSetup.configure = InternalConfigurePlugin.configure;
-     build = OCamlbuildPlugin.build;
+     build = OCamlbuildPlugin.build [];
      test =
        [
           ("core",
@@ -5706,7 +7466,7 @@
                  CustomPlugin.cmd_main =
                    [(OASISExpr.EBool true, ("$test_core", []))];
                  cmd_clean = [(OASISExpr.EBool true, None)];
-                 cmd_distclean = [(OASISExpr.EBool true, None)];
+                 cmd_distclean = [(OASISExpr.EBool true, None)]
                  });
           ("conv",
             CustomPlugin.Test.main
@@ -5714,7 +7474,7 @@
                  CustomPlugin.cmd_main =
                    [(OASISExpr.EBool true, ("$test_conv", []))];
                  cmd_clean = [(OASISExpr.EBool true, None)];
-                 cmd_distclean = [(OASISExpr.EBool true, None)];
+                 cmd_distclean = [(OASISExpr.EBool true, None)]
                  })
        ];
      doc = [];
@@ -5729,7 +7489,7 @@
                  CustomPlugin.cmd_main =
                    [(OASISExpr.EBool true, ("$test_core", []))];
                  cmd_clean = [(OASISExpr.EBool true, None)];
-                 cmd_distclean = [(OASISExpr.EBool true, None)];
+                 cmd_distclean = [(OASISExpr.EBool true, None)]
                  });
           ("conv",
             CustomPlugin.Test.clean
@@ -5737,7 +7497,7 @@
                  CustomPlugin.cmd_main =
                    [(OASISExpr.EBool true, ("$test_conv", []))];
                  cmd_clean = [(OASISExpr.EBool true, None)];
-                 cmd_distclean = [(OASISExpr.EBool true, None)];
+                 cmd_distclean = [(OASISExpr.EBool true, None)]
                  })
        ];
      clean_doc = [];
@@ -5750,7 +7510,7 @@
                  CustomPlugin.cmd_main =
                    [(OASISExpr.EBool true, ("$test_core", []))];
                  cmd_clean = [(OASISExpr.EBool true, None)];
-                 cmd_distclean = [(OASISExpr.EBool true, None)];
+                 cmd_distclean = [(OASISExpr.EBool true, None)]
                  });
           ("conv",
             CustomPlugin.Test.distclean
@@ -5758,7 +7518,7 @@
                  CustomPlugin.cmd_main =
                    [(OASISExpr.EBool true, ("$test_conv", []))];
                  cmd_clean = [(OASISExpr.EBool true, None)];
-                 cmd_distclean = [(OASISExpr.EBool true, None)];
+                 cmd_distclean = [(OASISExpr.EBool true, None)]
                  })
        ];
      distclean_doc = [];
@@ -5766,8 +7526,6 @@
        {
           oasis_version = "0.3";
           ocaml_version = None;
-          findlib_version = None;
-          name = "msgpack";
           version = "1.0.0";
           license =
             OASISLicense.DEP5License
@@ -5775,51 +7533,27 @@
                  {
                     OASISLicense.license = "MIT";
                     excption = None;
-                    version = OASISLicense.NoVersion;
+                    version = OASISLicense.NoVersion
                     });
+          findlib_version = None;
+          alpha_features = [];
+          beta_features = [];
+          name = "msgpack";
           license_file = None;
           copyrights = [];
           maintainers = [];
           authors = ["MIZUNO Hiroki"];
           homepage = Some "http://msgpack.org/";
+          bugreports = None;
           synopsis = "Msgpack library for Objective Caml";
           description =
             Some
-              "MessagePack is an efficient binary serialization format.\nIf meta_conv is installed, conv module will be installed.";
+              [
+                 OASISText.Para
+                   "MessagePack is an efficient binary serialization format. If meta_conv is installed, conv module will be installed."
+              ];
+          tags = [];
           categories = [];
-          conf_type = (`Configure, "internal", Some "0.3");
-          conf_custom =
-            {
-               pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
-               };
-          build_type = (`Build, "ocamlbuild", Some "0.3");
-          build_custom =
-            {
-               pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
-               };
-          install_type = (`Install, "internal", Some "0.3");
-          install_custom =
-            {
-               pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
-               };
-          uninstall_custom =
-            {
-               pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
-               };
-          clean_custom =
-            {
-               pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
-               };
-          distclean_custom =
-            {
-               pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
-               };
           files_ab = [];
           sections =
             [
@@ -5827,27 +7561,27 @@
                  ({
                      cs_name = "all";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
+                     cs_plugin_data = []
                      },
                    {
                       flag_description = Some "build and install everything";
-                      flag_default = [(OASISExpr.EBool true, false)];
+                      flag_default = [(OASISExpr.EBool true, false)]
                       });
                Flag
                  ({
                      cs_name = "core";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
+                     cs_plugin_data = []
                      },
                    {
                       flag_description = Some "Build the core library";
-                      flag_default = [(OASISExpr.EBool true, true)];
+                      flag_default = [(OASISExpr.EBool true, true)]
                       });
                Flag
                  ({
                      cs_name = "conv";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
+                     cs_plugin_data = []
                      },
                    {
                       flag_description = Some "Build the meta_conv library";
@@ -5855,13 +7589,13 @@
                         [
                            (OASISExpr.EBool true, false);
                            (OASISExpr.EFlag "all", true)
-                        ];
+                        ]
                       });
                Library
                  ({
                      cs_name = "msgpack";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
+                     cs_plugin_data = []
                      },
                    {
                       bs_build =
@@ -5885,10 +7619,120 @@
                            FindlibPackage ("extlib", None);
                            FindlibPackage ("num", None)
                         ];
-                      bs_build_tools =
-                        [ExternalTool "ocamlbuild"; ExternalTool "camlp4"];
+                      bs_build_tools = [ExternalTool "ocamlbuild"];
+                      bs_interface_patterns =
+                        [
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mli"
+                                ];
+                              origin = "${capitalize_file module}.mli"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mli"
+                                ];
+                              origin = "${uncapitalize_file module}.mli"
+                           }
+                        ];
+                      bs_implementation_patterns =
+                        [
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".ml"
+                                ];
+                              origin = "${capitalize_file module}.ml"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".ml"
+                                ];
+                              origin = "${uncapitalize_file module}.ml"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mll"
+                                ];
+                              origin = "${capitalize_file module}.mll"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mll"
+                                ];
+                              origin = "${uncapitalize_file module}.mll"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mly"
+                                ];
+                              origin = "${capitalize_file module}.mly"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mly"
+                                ];
+                              origin = "${uncapitalize_file module}.mly"
+                           }
+                        ];
                       bs_c_sources = [];
                       bs_data_files = [];
+                      bs_findlib_extra_files = [];
                       bs_ccopt = [(OASISExpr.EBool true, [])];
                       bs_cclib = [(OASISExpr.EBool true, [])];
                       bs_dlllib = [(OASISExpr.EBool true, [])];
@@ -5902,7 +7746,7 @@
                         [
                            (OASISExpr.EBool true,
                              ["-w"; "+a-27-39-4"; "-annot"])
-                        ];
+                        ]
                       },
                    {
                       lib_modules = ["Msgpack"];
@@ -5918,13 +7762,14 @@
                         ];
                       lib_findlib_parent = None;
                       lib_findlib_name = None;
-                      lib_findlib_containers = [];
+                      lib_findlib_directory = None;
+                      lib_findlib_containers = []
                       });
                Library
                  ({
                      cs_name = "msgpack_conv";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
+                     cs_plugin_data = []
                      },
                    {
                       bs_build =
@@ -5948,10 +7793,120 @@
                            FindlibPackage ("meta_conv", None);
                            InternalLibrary "msgpack"
                         ];
-                      bs_build_tools =
-                        [ExternalTool "ocamlbuild"; ExternalTool "camlp4"];
+                      bs_build_tools = [ExternalTool "ocamlbuild"];
+                      bs_interface_patterns =
+                        [
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mli"
+                                ];
+                              origin = "${capitalize_file module}.mli"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mli"
+                                ];
+                              origin = "${uncapitalize_file module}.mli"
+                           }
+                        ];
+                      bs_implementation_patterns =
+                        [
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".ml"
+                                ];
+                              origin = "${capitalize_file module}.ml"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".ml"
+                                ];
+                              origin = "${uncapitalize_file module}.ml"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mll"
+                                ];
+                              origin = "${capitalize_file module}.mll"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mll"
+                                ];
+                              origin = "${uncapitalize_file module}.mll"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mly"
+                                ];
+                              origin = "${capitalize_file module}.mly"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mly"
+                                ];
+                              origin = "${uncapitalize_file module}.mly"
+                           }
+                        ];
                       bs_c_sources = [];
                       bs_data_files = [];
+                      bs_findlib_extra_files = [];
                       bs_ccopt = [(OASISExpr.EBool true, [])];
                       bs_cclib = [(OASISExpr.EBool true, [])];
                       bs_dlllib = [(OASISExpr.EBool true, [])];
@@ -5959,7 +7914,7 @@
                       bs_byteopt =
                         [(OASISExpr.EBool true, ["-w"; "+a"; "-annot"])];
                       bs_nativeopt =
-                        [(OASISExpr.EBool true, ["-w"; "+a"; "-annot"])];
+                        [(OASISExpr.EBool true, ["-w"; "+a"; "-annot"])]
                       },
                    {
                       lib_modules = ["Msgpack_conv"];
@@ -5967,13 +7922,14 @@
                       lib_internal_modules = ["Encode"; "Decode"];
                       lib_findlib_parent = Some "msgpack";
                       lib_findlib_name = Some "conv";
-                      lib_findlib_containers = [];
+                      lib_findlib_directory = None;
+                      lib_findlib_containers = []
                       });
                Executable
                  ({
                      cs_name = "test_core";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
+                     cs_plugin_data = []
                      },
                    {
                       bs_build =
@@ -5994,23 +7950,133 @@
                            InternalLibrary "msgpack";
                            FindlibPackage ("oUnit", None)
                         ];
-                      bs_build_tools =
-                        [ExternalTool "ocamlbuild"; ExternalTool "camlp4"];
+                      bs_build_tools = [ExternalTool "ocamlbuild"];
+                      bs_interface_patterns =
+                        [
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mli"
+                                ];
+                              origin = "${capitalize_file module}.mli"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mli"
+                                ];
+                              origin = "${uncapitalize_file module}.mli"
+                           }
+                        ];
+                      bs_implementation_patterns =
+                        [
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".ml"
+                                ];
+                              origin = "${capitalize_file module}.ml"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".ml"
+                                ];
+                              origin = "${uncapitalize_file module}.ml"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mll"
+                                ];
+                              origin = "${capitalize_file module}.mll"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mll"
+                                ];
+                              origin = "${uncapitalize_file module}.mll"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mly"
+                                ];
+                              origin = "${capitalize_file module}.mly"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mly"
+                                ];
+                              origin = "${uncapitalize_file module}.mly"
+                           }
+                        ];
                       bs_c_sources = [];
                       bs_data_files = [];
+                      bs_findlib_extra_files = [];
                       bs_ccopt = [(OASISExpr.EBool true, [])];
                       bs_cclib = [(OASISExpr.EBool true, [])];
                       bs_dlllib = [(OASISExpr.EBool true, [])];
                       bs_dllpath = [(OASISExpr.EBool true, [])];
                       bs_byteopt = [(OASISExpr.EBool true, [])];
-                      bs_nativeopt = [(OASISExpr.EBool true, [])];
+                      bs_nativeopt = [(OASISExpr.EBool true, [])]
                       },
-                   {exec_custom = false; exec_main_is = "main.ml"; });
+                   {exec_custom = false; exec_main_is = "main.ml"});
                Executable
                  ({
                      cs_name = "test_conv";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
+                     cs_plugin_data = []
                      },
                    {
                       bs_build =
@@ -6033,32 +8099,142 @@
                            FindlibPackage ("oUnit", None);
                            FindlibPackage ("meta_conv.syntax", None)
                         ];
-                      bs_build_tools =
-                        [ExternalTool "ocamlbuild"; ExternalTool "camlp4"];
+                      bs_build_tools = [ExternalTool "ocamlbuild"];
+                      bs_interface_patterns =
+                        [
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mli"
+                                ];
+                              origin = "${capitalize_file module}.mli"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mli"
+                                ];
+                              origin = "${uncapitalize_file module}.mli"
+                           }
+                        ];
+                      bs_implementation_patterns =
+                        [
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".ml"
+                                ];
+                              origin = "${capitalize_file module}.ml"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".ml"
+                                ];
+                              origin = "${uncapitalize_file module}.ml"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mll"
+                                ];
+                              origin = "${capitalize_file module}.mll"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mll"
+                                ];
+                              origin = "${uncapitalize_file module}.mll"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("capitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mly"
+                                ];
+                              origin = "${capitalize_file module}.mly"
+                           };
+                           {
+                              OASISSourcePatterns.Templater.atoms =
+                                [
+                                   OASISSourcePatterns.Templater.Text "";
+                                   OASISSourcePatterns.Templater.Expr
+                                     (OASISSourcePatterns.Templater.Call
+                                        ("uncapitalize_file",
+                                          OASISSourcePatterns.Templater.Ident
+                                            "module"));
+                                   OASISSourcePatterns.Templater.Text ".mly"
+                                ];
+                              origin = "${uncapitalize_file module}.mly"
+                           }
+                        ];
                       bs_c_sources = [];
                       bs_data_files = [];
+                      bs_findlib_extra_files = [];
                       bs_ccopt = [(OASISExpr.EBool true, [])];
                       bs_cclib = [(OASISExpr.EBool true, [])];
                       bs_dlllib = [(OASISExpr.EBool true, [])];
                       bs_dllpath = [(OASISExpr.EBool true, [])];
                       bs_byteopt = [(OASISExpr.EBool true, [])];
-                      bs_nativeopt = [(OASISExpr.EBool true, [])];
+                      bs_nativeopt = [(OASISExpr.EBool true, [])]
                       },
-                   {exec_custom = false; exec_main_is = "main.ml"; });
+                   {exec_custom = false; exec_main_is = "main.ml"});
                Test
                  ({
                      cs_name = "core";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
+                     cs_plugin_data = []
                      },
                    {
-                      test_type = (`Test, "custom", Some "0.3");
+                      test_type = (`Test, "custom", Some "0.4");
                       test_command =
                         [(OASISExpr.EBool true, ("$test_core", []))];
                       test_custom =
                         {
                            pre_command = [(OASISExpr.EBool true, None)];
-                           post_command = [(OASISExpr.EBool true, None)];
+                           post_command = [(OASISExpr.EBool true, None)]
                            };
                       test_working_directory = None;
                       test_run =
@@ -6077,24 +8253,23 @@
                       test_tools =
                         [
                            ExternalTool "ocamlbuild";
-                           ExternalTool "camlp4";
                            InternalExecutable "test_core"
-                        ];
+                        ]
                       });
                Test
                  ({
                      cs_name = "conv";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
+                     cs_plugin_data = []
                      },
                    {
-                      test_type = (`Test, "custom", Some "0.3");
+                      test_type = (`Test, "custom", Some "0.4");
                       test_command =
                         [(OASISExpr.EBool true, ("$test_conv", []))];
                       test_custom =
                         {
                            pre_command = [(OASISExpr.EBool true, None)];
-                           post_command = [(OASISExpr.EBool true, None)];
+                           post_command = [(OASISExpr.EBool true, None)]
                            };
                       test_working_directory = None;
                       test_run =
@@ -6113,15 +8288,14 @@
                       test_tools =
                         [
                            ExternalTool "ocamlbuild";
-                           ExternalTool "camlp4";
                            InternalExecutable "test_conv"
-                        ];
+                        ]
                       });
                SrcRepo
                  ({
                      cs_name = "head";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
+                     cs_plugin_data = []
                      },
                    {
                       src_repo_type = Git;
@@ -6132,24 +8306,60 @@
                       src_repo_module = None;
                       src_repo_branch = None;
                       src_repo_tag = None;
-                      src_repo_subdir = None;
+                      src_repo_subdir = None
                       })
             ];
+          disable_oasis_section = [];
+          conf_type = (`Configure, "internal", Some "0.4");
+          conf_custom =
+            {
+               pre_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
+            };
+          build_type = (`Build, "ocamlbuild", Some "0.4");
+          build_custom =
+            {
+               pre_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
+            };
+          install_type = (`Install, "internal", Some "0.4");
+          install_custom =
+            {
+               pre_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
+            };
+          uninstall_custom =
+            {
+               pre_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
+            };
+          clean_custom =
+            {
+               pre_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
+            };
+          distclean_custom =
+            {
+               pre_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
+            };
           plugins =
             [(`Extra, "META", Some "0.3"); (`Extra, "DevFiles", Some "0.3")];
           schema_data = PropList.Data.create ();
-          plugin_data = [];
+          plugin_data = []
           };
      oasis_fn = Some "_oasis";
-     oasis_version = "0.3.0";
-     oasis_digest = Some "j]+c\029\181\160\029\235\201\223p\235\166\243!";
+     oasis_version = "0.4.7";
+     oasis_digest = Some "\163NAC\220\195\205\rDX?\139\152t\164e";
      oasis_exec = None;
      oasis_setup_args = [];
-     setup_update = false;
+     setup_update = false
      };;
 
 let setup () = BaseSetup.setup setup_t;;
 
-# 6154 "setup.ml"
+# 8362 "setup.ml"
+let setup_t = BaseCompat.Compat_0_3.adapt_setup_t setup_t
+open BaseCompat.Compat_0_3
 (* OASIS_STOP *)
 let () = setup ();;
